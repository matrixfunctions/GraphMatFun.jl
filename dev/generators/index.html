<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Built-in graphs · GraphMatFun.jl</title><link rel="canonical" href="https://matrixfunctions.github.io/GraphMatFun.jl/generators/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GraphMatFun.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../graph/">Graphs and their manipulation</a></li><li class="is-active"><a class="tocitem" href>Built-in graphs</a><ul class="internal"><li><a class="tocitem" href="#Polynomails"><span>Polynomails</span></a></li><li><a class="tocitem" href="#Degree-optimal-polynomails"><span>Degree-optimal polynomails</span></a></li><li><a class="tocitem" href="#Matrix-exponential"><span>Matrix exponential</span></a></li><li><a class="tocitem" href="#Other-matrix-functions"><span>Other matrix functions</span></a></li></ul></li><li><a class="tocitem" href="../optim/">Graph optimization</a></li><li><a class="tocitem" href="../code_gen/">Code generation and efficiency</a></li></ul></li><li><a class="tocitem" href="../docidx/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Built-in graphs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Built-in graphs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/master/docs/src/generators.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Built-in-graphs"><a class="docs-heading-anchor" href="#Built-in-graphs">Built-in graphs</a><a id="Built-in-graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-graphs" title="Permalink"></a></h1><h2 id="Polynomails"><a class="docs-heading-anchor" href="#Polynomails">Polynomails</a><a id="Polynomails-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomails" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_monomial" href="#GraphMatFun.graph_monomial"><code>GraphMatFun.graph_monomial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_monomial(a; input=:A, polyname=:P)</code></pre><p>Generates the graph for the polynomial using the monomial basis coefficients. More precisely, it corresponds to the evaluation of the polynomial</p><pre><code class="language-none">p(s) = a[1] + a[2]*s + ... + a[n]*s^(n-1),</code></pre><p>where s^k is naively evaluated as s^k=s*s^(k-1) for k=2,3,...,n-1. The kwarg <code>polyname</code> specifies the name of intermediate variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/monomial_poly.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_monomial_degopt" href="#GraphMatFun.graph_monomial_degopt"><code>GraphMatFun.graph_monomial_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_monomial_degopt(a; input=:A)</code></pre><p>Generates the same polynomial as <a href="#GraphMatFun.graph_monomial"><code>graph_monomial</code></a>, in the monomial basis. However, it does so by wrapping a call to <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>, resulting in more degrees of freedom in <code>crefs</code>.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/monomial_poly.jl#L55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_horner" href="#GraphMatFun.graph_horner"><code>GraphMatFun.graph_horner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_horner(a; input=:A, B=:B, C=:C, scaling=1.0)</code></pre><p>Generates the graph for the polynomial using Horner&#39;s method. More precisely, it corresponds to the evaluation of the polynomial</p><pre><code class="language-none">p(s) = a[1] + a[2]*(αs) + ... + a[n-1]*(αs)^(n-2) + a[n]*(αs)^(n-1),</code></pre><p>as the recursion</p><pre><code class="language-none">Cj=s*B{j+1}
Bj=a[j]*I+α*Cj,</code></pre><p>where α=<code>scaling</code>.</p><p>The kwargs <code>B</code> and <code>C</code> specifies the base-names of these intermediate variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/horner.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_horner_degopt" href="#GraphMatFun.graph_horner_degopt"><code>GraphMatFun.graph_horner_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_horner_degopt(a; scaling=1.0, input=:A)</code></pre><p>Generates a polynomial using Horner&#39;s evaluation scheme. The polynomial</p><pre><code class="language-none"> p(s) = a[1] + a[2]*(αs) + ... + a[n-1]*(αs)^(n-2) + a[n]*(αs)^(n-1),</code></pre><p>is evaluated as</p><pre><code class="language-none"> p(s) = a[1] + (αs)*(a[2] + (αs)*(... + (αs)*(a[n-1] + a[n]*(αs))...)),</code></pre><p>where α=<code>scaling</code>. However, the function uses a call to <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>, resulting in more degrees of freedom in <code>crefs</code>. See also <a href="#GraphMatFun.graph_horner"><code>graph_horner</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/horner.jl#L59-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_ps" href="#GraphMatFun.graph_ps"><code>GraphMatFun.graph_ps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_ps(a; input=:A,
                      B_base=:B, C_base=:C, P_base=:P)</code></pre><p>Generates the graph for the Paterson–Stockmeyer procedure with monomial basis coefficieents. More precily, it corresponds to evaluation of the polynomial</p><pre><code class="language-none">p(s) = a[1] + a[2]*s + ... + a[n]*s^(n-1).</code></pre><p>Reference:</p><ul><li>On the number of nonscalar multiplications necessary to evaluate polynomials, M. Paterson, L. Stockmeyer, SIAM J. Comput., 2(1), 1973.</li></ul><p>The code follows the description in:</p><ul><li><p>Optimality of the Paterson–Stockmeyer method for evaluating matrix polynomials and rational matrix functions, M. Fasi, Linear Algebra Appl., 574, 2019.</p><pre><code class="language-none"></code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/ps_poly.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_ps_degopt" href="#GraphMatFun.graph_ps_degopt"><code>GraphMatFun.graph_ps_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_ps_degopt(a; input=:A)</code></pre><p>Generates the same polynomial as <a href="#GraphMatFun.graph_ps"><code>graph_ps</code></a>, i.e., the graph for the Paterson–Stockmeyer procedure with monomial basis coefficieents. However, it does so by wrapping a call to <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>, resulting in more degrees of freedom in <code>crefs</code>.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/ps_poly.jl#L140-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_sastre_poly" href="#GraphMatFun.graph_sastre_poly"><code>GraphMatFun.graph_sastre_poly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_sastre_poly(b)</code></pre><p>Computes the degree-8 polynomial</p><pre><code class="language-none">p(z)=b[1]+z*b[2]+z^2*b[3]+...+z^8*b[9]</code></pre><p>according to Example 3.1 in the reference.</p><p>Reference:</p><ul><li>Efficient evaluation of matrix polynomials, J. Sastre. Linear Algebra and its Applications ,Volume 539, 2018, Pages 229-250, DOI: <a href="https://doi.org/10.1016/j.laa.2017.11.010">10.1016/j.laa.2017.11.010</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/sastre.jl#L163-L175">source</a></section></article><h2 id="Degree-optimal-polynomails"><a class="docs-heading-anchor" href="#Degree-optimal-polynomails">Degree-optimal polynomails</a><a id="Degree-optimal-polynomails-1"></a><a class="docs-heading-anchor-permalink" href="#Degree-optimal-polynomails" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.Degopt" href="#GraphMatFun.Degopt"><code>GraphMatFun.Degopt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">degopt=Degopt(x,y)
degopt=Degopt(HA,HB,y)
degopt=Degopt(graph)

struct Degopt{T}
    x::Vector{Tuple{Vector{T},Vector{T}}}
    y::Vector{T}
end</code></pre><p>Creates an object representing a degree optimal polynomial, i.e., the coefficients in an evaluation scheme which maximizes the degree for a fixed number of multiplications. The object represents the coefficients in</p><pre><code class="language-none">A0=I
A1=A
A2=(x *A0+x *A1)(x *A0+x *A1)
A4=(x *A0+x *A1+x*A2)(x *A0+x *A1+x *A2)
A8=(x *A0+x *A1+x*A2)(x *A0+x *A1+x *A2)
 ..</code></pre><p>and</p><pre><code class="language-none">Out=y*A0+y*A1+y*A4+y*A8+y*B4...</code></pre><p>The <code>x</code>-values are given in the argument <code>x</code>, which is a <code>Vector{Tuple{Vector{T},Vector{T}}}</code>, containing the elements of each sum. The <code>y</code>-vector contains the elements to form the output. In the constructor with <code>HA</code>, <code>HB</code> and <code>y</code> the elements of <code>x</code> are stored as matrices.</p><p>The coefficients in graphs generated by <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a> can be recovered by using <code>Degopt(graph)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/degopt.jl#L10-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_degopt" href="#GraphMatFun.graph_degopt"><code>GraphMatFun.graph_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,crefs)=graph_degopt(k;T=ComplexF64,input=:A)
(graph,crefs)=graph_degopt(x,z;input=:A)
(graph,crefs)=graph_degopt(d::Degopt;input=:A)</code></pre><p>Corresponds to the (for a fixed numer of multiplications) degree-optimal polynomial</p><pre><code class="language-none">B1=A
B2=(x *I+x *A)(x *I+x *A)
B3=(x *I+x *A+x*B2)(x *I+x *A+x *B2)
 ..</code></pre><p>and</p><pre><code class="language-none">Out=z*I+z*A1+z*B2+z*B3+z*B4...</code></pre><p>The <code>x</code>-values are given in the argument <code>x</code>, which is a <code>Vector{Tuple{Vector,Vector}}</code>, containing the elements of each sum. The <code>z</code>-vector contains the elements to form the output, and <code>input</code> determines the name of the matrix A above. If the parameter <code>k</code> is supplied instead of the coefficients, all coeffs will be set to one.</p><p>Reference: The general recursion is mentioned in equation (9) in this paper:</p><ul><li>Computing the matrix exponential with an optimized Taylor polynomial approximation, P. Bader, S. Blanes, and F. Casas, Mathematics, 7(12), 2019.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/degopt_poly.jl#L4-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.grow!" href="#GraphMatFun.grow!"><code>GraphMatFun.grow!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grow!(degopt::Degopt)</code></pre><p>Increases the <a href="#GraphMatFun.Degopt"><code>Degopt</code></a> by one multiplication without modifying the function values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/degopt.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.scale!" href="#GraphMatFun.scale!"><code>GraphMatFun.scale!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scale!(degopt::Degopt,α)</code></pre><p>Effectively change a <a href="#GraphMatFun.Degopt"><code>Degopt</code></a> such that the input is scaled by <code>α</code>. If <code>p</code> is the original function, <code>p(α x)</code> will be the new function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/degopt.jl#L152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.square!" href="#GraphMatFun.square!"><code>GraphMatFun.square!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">square!(degopt::Degopt)</code></pre><p>Effectively square a <a href="#GraphMatFun.Degopt"><code>Degopt</code></a> in the sense that the output is square. If <code>p</code> is the original function, <code>p(x)^2</code> will be the new function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/degopt.jl#L168-L173">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>normalize!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_degopt_coeffs" href="#GraphMatFun.get_degopt_coeffs"><code>GraphMatFun.get_degopt_coeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_degopt_coeffs(degopt) -&gt; (HA,HB,y)
get_degopt_coeffs(graph) -&gt; (HA,HB,y)</code></pre><p>Returns the coefficients of the degree-optimal polynomial using two matrices and one vectors as described in <a href="#GraphMatFun.Degopt"><code>Degopt</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/degopt.jl#L228-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_degopt_crefs" href="#GraphMatFun.get_degopt_crefs"><code>GraphMatFun.get_degopt_crefs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x,z)=get_degopt_crefs(k)
(x,z)=get_degopt_crefs(graph)</code></pre><p>Retruns crefs related to <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>. Specifically <code>x</code> is a <code>Vector{Tuple{Vector{Tuple{Symbol,Int}},Vector{Tuple{Symbol,Int}}}}</code> such that <code>x[2][1]</code> corresponds to the coefficients of the left hand side of the multiplication</p><pre><code class="language-none">B2=(α_2_1 *I + α_2_2 *A)(β_2_1 *I + β_2_2 *A)</code></pre><p>i.e., the crefs corresponding to <code>[α_2_1, α_2_2]</code>. See <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>. Hence, <code>get_coeffs(graph,x[2][1])</code> returns the corresponding numerical values of the coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/degopt.jl#L97-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_topo_order_degopt" href="#GraphMatFun.get_topo_order_degopt"><code>GraphMatFun.get_topo_order_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">order=get_topo_order_degopt(k)</code></pre><p>A special implementation of <a href="../graph/#GraphMatFun.get_topo_order"><code>get_topo_order</code></a> for degree optimal polynomials generated with <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>. The natural order of computation is to compute row by row. See also <a href="#GraphMatFun.get_degopt_crefs"><code>get_degopt_crefs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/degopt_poly.jl#L117-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_sastre_yks_degopt" href="#GraphMatFun.graph_sastre_yks_degopt"><code>GraphMatFun.graph_sastre_yks_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_sastre_yks_degopt(k,s,c)</code></pre><p>Transforms the polynomial evaluation format given by equations (62)-(65) in the reference to <code>degop</code>-format. The <code>graph</code> is a representation of y_{<code>k</code> <code>s</code>}. Input <code>c</code> is a grouping of the coefficients as given by the representation (62)-(65). <code>c</code> is a <code>Vector{Vector{Vector}}</code> of length <code>k</code>+1, representing</p><pre><code class="language-none">[
[c_i^{(0,1)}, c_i^{(0,2)}]
[c_i^{(1,1)}, c_i^{(1,2)}, c_i^{(1,3)}, c_i^{(1,4)}, c_i^{(1,5)}, c_i^{(1,6)}]
...
[c_i^{(k,1)}, c_i^{(k,2)}, c_i^{(k,3)}, c_i^{(k,4)}, c_i^{(k,5)}, c_i^{(k,6)}]
]</code></pre><p>Hence, <code>c[1]</code> contains two vectors, the first of length <code>s</code>-1 and the second of length <code>s</code>. (Note: In the first vector the constant for I is set to zero) and <code>c[2]</code> up to <code>c[k+1]</code> conatins six vectors: Even-numbered vectors have length <code>s</code>+1 Odd-numbered vectors have length j-1, where j is the intex in <code>c</code>, e.g., <code>c[2][1]</code> has one element and <code>c[3][5]</code> have two. For example, equations (57)-(59) are implemented as:</p><pre><code class="language-none">c = [
[[c15, c16], [0.0, 0, 0]], # (57)
[[1.0], [0, c13, c14], [1.0], [c11, 0, c12], [c10], [0.0, 0, 0]], # (58)
[[0.0, 1], [0, c8, c9], [c7, 1], [0, c6, 0], [c4, c5], [c1, c2, c3]], # (59)
]</code></pre><p>Reference:</p><ul><li>Efficient evaluation of matrix polynomials, J. Sastre. Linear Algebra and its Applications ,Volume 539, 2018, Pages 229-250, DOI: <a href="https://doi.org/10.1016/j.laa.2017.11.010">10.1016/j.laa.2017.11.010</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/sastre.jl#L219-L251">source</a></section></article><h2 id="Matrix-exponential"><a class="docs-heading-anchor" href="#Matrix-exponential">Matrix exponential</a><a id="Matrix-exponential-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-exponential" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_exp_native_jl" href="#GraphMatFun.graph_exp_native_jl"><code>GraphMatFun.graph_exp_native_jl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_exp_native_jl(A; input=:A)</code></pre><p>Creates a graph for the native scaling-and-squaring for the matrix exponential, as implemented in Julia. The matrix <code>A</code> is taken as input to determine the length of the Padé approximant and the number of squares applied, as well as determining the type of the coefficients. The kwarg <code>input</code> determines the name of the matrix, in the graph.</p><p>References:</p><ul><li><p>N. J. Higham. Functions of Matrices. SIAM publications, Philadelphia, PA, 2008.</p></li><li><p>N. J. Higham. The Scaling and Squaring Method for the Matrix Exponential Revisited. SIAM J. Matrix Anal. Appl., 2005 26:4, 1179-1193</p></li><li><p>Julia&#39;s matrix exponential, <a href="https://github.com/JuliaLang/julia/blob/697e782ab86bfcdd7fd15550241fe162c51d9f98/stdlib/LinearAlgebra/src/dense.jl#L554">at the time of conversion</a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/exp.jl#L29-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_exp_native_jl_degopt" href="#GraphMatFun.graph_exp_native_jl_degopt"><code>GraphMatFun.graph_exp_native_jl_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_exp_native_jl_degopt(A; input=:A)</code></pre><p>Same as <a href="#GraphMatFun.graph_exp_native_jl"><code>graph_exp_native_jl</code></a> but with calls to <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a> for contruction of numerator and denominator polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/exp.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_sastre_exp" href="#GraphMatFun.graph_sastre_exp"><code>GraphMatFun.graph_sastre_exp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_sastre_exp(k,method=:auto)</code></pre><p>Computes a polynomial evaluation approximating the exponential using <code>k</code> matrix multiplications following a <code>method</code> given in the reference. The schemes are embedded into <code>degop</code>-format, see <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>.</p><p>Methods are:</p><ul><li><code>:ps_degopt</code>, Paterson–Stockmeyer method embedded into <code>degopt</code>-format.</li><li><code>:y1s</code>, given by equations (34)-(35)</li><li><code>:z1ps</code>, given by equations (34)-(35) and (52)</li><li><code>:h2m</code>, given by equations (34)-(35) and (69)</li></ul><p>Not all combinations of <code>k</code> and <code>method</code> are implemented. Available ones are:</p><ul><li><code>k</code>&lt;3, <code>method</code>=<code>:ps_degopt</code></li><li><code>k</code>=3, <code>method</code>=<code>:y1s</code>, as per Table 4 in the reference</li><li><code>k</code>=4, <code>method</code>=<code>:y1s</code></li><li><code>k</code>=6, <code>method</code>=<code>:h2m</code>, as per Table 11 in the reference</li><li><code>k</code>=8, <code>method</code>=<code>:z1ps</code>, as per Table 7 in the reference</li></ul><p>The default option <code>method=:auto</code> will choose method according to the value of <code>k</code>, as prescribed above.</p><p>Reference:</p><ul><li>Efficient evaluation of matrix polynomials, J. Sastre. Linear Algebra and its Applications ,Volume 539, 2018, Pages 229-250, DOI: <a href="https://doi.org/10.1016/j.laa.2017.11.010">10.1016/j.laa.2017.11.010</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/sastre.jl#L4-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_sid_exp" href="#GraphMatFun.graph_sid_exp"><code>GraphMatFun.graph_sid_exp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_sid_exp(k;T=Float64)</code></pre><p>Computes a polynomial evaluation approximating the exponential using <code>k</code> matrix multiplications following the procedure in the reference. The coefficients are directly copied from the paper.</p><p>The evaluation is embedded in the degopt-format, see <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>, using the function <a href="#GraphMatFun.graph_sastre_yks_degopt"><code>graph_sastre_yks_degopt</code></a>. Moreover, for <code>k</code>&lt;=3 it uses the Paterson–Stockmeyer method.</p><p>Reference:</p><ul><li><p>Boosting the computation of the matrix exponential, J. Sastre, J. Ibáñez, E. Defez, Appl. Math. Computation, 340, 2019, 206-220.</p><pre><code class="language-none"></code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/sid.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_bbc_exp" href="#GraphMatFun.graph_bbc_exp"><code>GraphMatFun.graph_bbc_exp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_bbc_exp(k;T=Float64)</code></pre><p>Computes a polynomial evaluation approximating the exponential using <code>k</code> matrix multiplications following the procedure in the reference. The coefficients are directly copied from the paper.</p><p>The evaluation is embedded in the <code>degopt</code>-format, see <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>, and for <code>k</code>&lt;3, the evaluation is using the Paterson–Stockmeyer method.</p><p>Reference:</p><ul><li><p>Computing the matrix exponential with an optimized Taylor polynomial approximation, P. Bader, S. Blanes, and F. Casas, Mathematics, 7(12), 2019.</p><pre><code class="language-none"></code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/bbc_exp.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_bbcs_cheb_exp" href="#GraphMatFun.graph_bbcs_cheb_exp"><code>GraphMatFun.graph_bbcs_cheb_exp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_bbcs_cheb_exp(k;T=Complex{BigFloat})</code></pre><p>Computes a polynomial evaluation approximating the exponential for skew-Hermitian matrices using <code>k</code> matrix multiplications following the procedure in the reference.</p><p>For <code>k</code> &gt; 5 it resorts to scaling-and-squaring of the <code>k</code> = 5 graph. The graph is in the degopt format, see <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>.</p><p>Reference:</p><ul><li><p>An efficient algorithm to compute the exponential of skew-Hermitian matrices for the time integration of the Schrödinger equation, P. Bader, S. Blanes, F. Casas, M. Seydaoglu, arXiv:2103.10132</p><pre><code class="language-none"></code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/bbcs_cheb_exp.jl#L3-L17">source</a></section></article><h2 id="Other-matrix-functions"><a class="docs-heading-anchor" href="#Other-matrix-functions">Other matrix functions</a><a id="Other-matrix-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-matrix-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_rational" href="#GraphMatFun.graph_rational"><code>GraphMatFun.graph_rational</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph, cref) = graph_rational(den_coeffs, num_coeffs, poly_gen=graph_ps)
 (graph, cref) = graph_rational(den_graph, den_graph; den_cref=Vector{Tuple{Symbol,Int}}(), num_cref=Vector{Tuple{Symbol,Int}}())</code></pre><p>Generates the graph for the rational approximation</p><pre><code class="language-none">r(A)=q(A)^{-1}p(A)</code></pre><p>where p(A) and q(A) are polynomials defined by the coeficients <code>den_coeffs</code> and <code>num_coeffs</code>, and generated by the function <code>poly_gen</code>, which is called as (graph,cref)=poly<em>gen(coeffs), see, e.g., `graph</em>monomial<code>and</code>graph_ps`.</p><p>The alternative call-signature involves the graphs for p and q directly, as <code>den_graph</code> and <code>num_graph</code>. The corresponding <code>den_cref</code> and <code>num_cref</code> can also be passed to be modified accodringly, otherwise the return value <code>cref</code> is empty for this call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/rational.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_denman_beavers" href="#GraphMatFun.graph_denman_beavers"><code>GraphMatFun.graph_denman_beavers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    (graph,cref)=graph_denman_beavers(k;T=ComplexF64,cref_mode=0)</code></pre><p>Creates the graph corresponding to the Denman-Beavers iteration for the matrix square root, using k iterations. The kwarg <code>cref_mode</code> specifies if references to all X and Y (<code>cref_mode=0</code>) should be stored or just Y (<code>cref_mode=-1</code>) or just X (<code>cref_mode=1</code>).</p><p>Reference:</p><ul><li>The matrix sign function and computations in systems, E. Denman,  A. Beavers, Applied Mathematics and Computation, 2(1), 1976, DOI: <a href="https://doi.org/10.1016/0096-3003(76)90020-5">10.1016/0096-3003(76)90020-5</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/denman_beavers_gen.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_newton_schulz" href="#GraphMatFun.graph_newton_schulz"><code>GraphMatFun.graph_newton_schulz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_newton_schulz(k, T=ComplexF64; input=:A, B=:B, C=:C, V=:V)</code></pre><p>Does <code>k</code> iterations of the Newton–Schulz iteration for approximating the inverse of a matrix A (name given by <code>input</code>), i.e., the recursion</p><pre><code class="language-none">V_k+1 = V_k*(2*I - A*V_k),</code></pre><p>with V_0=A. The recursion is implemented using the graph-operations</p><pre><code class="language-none">Z_i=A*V_i
Q_i=2*I-Z_i
V_{i+1}=V_i*Q_i,</code></pre><p>and the kwargs  <code>Z</code>, <code>Q</code>, and <code>V</code> determines the naming of the corresponding intermediate steps.</p><p>References:</p><ul><li><p>Günther Schulz. Iterative Berechnung der reziproken Matrix. Z. Angew. Math. Mech., 13:57–59, 1933. DOI: <a href="https://doi.org/10.1002/zamm.19330130111">10.1002/zamm.19330130111</a></p></li><li><p>N. J. Higham. Functions of Matrices. SIAM publications, Philadelphia, PA, 2008.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/newton_schulz.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_newton_schulz_degopt" href="#GraphMatFun.graph_newton_schulz_degopt"><code>GraphMatFun.graph_newton_schulz_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_newton_schulz_degopt(k, T=ComplexF64; input=:A)</code></pre><p>Does <code>k</code> iterations of the Newton–Schulz iteration for approximating the inverse, using the recursion</p><pre><code class="language-none">Z_i=A*V_i
V_{i+1}=V_i*(2*I-Z_i).</code></pre><p>The function makes a call to <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>, resulting in more degrees of freedom in <code>crefs</code>. See also <code>graph_newton_schulz</code>.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/e5accd5beeb8e4bdc99b4888c684aa43bbe18842/src/generators/newton_schulz.jl#L54-L66">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../graph/">« Graphs and their manipulation</a><a class="docs-footer-nextpage" href="../optim/">Graph optimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 30 June 2021 12:31">Wednesday 30 June 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
