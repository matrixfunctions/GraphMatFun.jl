<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Built-in graphs · GraphMatFun.jl</title><link rel="canonical" href="https://matrixfunctions.github.io/GraphMatFun.jl/generators/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GraphMatFun.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../graph/">Graphs and their manipulation</a></li><li class="is-active"><a class="tocitem" href>Built-in graphs</a><ul class="internal"><li><a class="tocitem" href="#Polynomials"><span>Polynomials</span></a></li><li><a class="tocitem" href="#Degree-optimal-polynomials"><span>Degree-optimal polynomials</span></a></li><li><a class="tocitem" href="#Rational-functions"><span>Rational functions</span></a></li><li><a class="tocitem" href="#Matrix-exponential"><span>Matrix exponential</span></a></li><li><a class="tocitem" href="#Other-matrix-functions-and-iterations"><span>Other matrix functions and iterations</span></a></li></ul></li><li><a class="tocitem" href="../optim/">Graph optimization</a></li><li><a class="tocitem" href="../code_gen/">Code generation and efficiency</a></li></ul></li><li><a class="tocitem" href="../docidx/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Built-in graphs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Built-in graphs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/master/docs/src/generators.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Built-in-graphs"><a class="docs-heading-anchor" href="#Built-in-graphs">Built-in graphs</a><a id="Built-in-graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-graphs" title="Permalink"></a></h1><h2 id="Polynomials"><a class="docs-heading-anchor" href="#Polynomials">Polynomials</a><a id="Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomials" title="Permalink"></a></h2><p>Standard evaluation schemes such as monomial evaluation (<a href="#GraphMatFun.graph_monomial"><code>graph_monomial</code></a>), Horner evaluation (<a href="#GraphMatFun.graph_horner"><code>graph_horner</code></a>) and Paterson–Stockmeyer (<a href="#GraphMatFun.graph_ps"><code>graph_ps</code></a>) are available. There are also the degree-optimal polynomials (<a href="#GraphMatFun.Degopt"><code>Degopt</code></a>) described in the next section.</p><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_monomial" href="#GraphMatFun.graph_monomial"><code>GraphMatFun.graph_monomial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_monomial(a; input=:A, polyname=:P)</code></pre><p>Generates the graph for the polynomial using the monomial basis coefficients. More precisely, it corresponds to the evaluation of the polynomial</p><pre><code class="language-none">p(s) = a[1] + a[2]*s + ... + a[n]*s^(n-1),</code></pre><p>where s^k is naively evaluated as s^k=s*s^(k-1) for k=2,3,...,n-1. The kwarg <code>polyname</code> specifies the name of intermediate variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/monomial_poly.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_monomial_degopt" href="#GraphMatFun.graph_monomial_degopt"><code>GraphMatFun.graph_monomial_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_monomial_degopt(a; input=:A)</code></pre><p>Generates the same polynomial as <a href="#GraphMatFun.graph_monomial"><code>graph_monomial</code></a>, in the monomial basis. However, it does so by wrapping a call to <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>, resulting in more degrees of freedom in <code>crefs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/monomial_poly.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_horner" href="#GraphMatFun.graph_horner"><code>GraphMatFun.graph_horner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_horner(a; input=:A, B=:B, C=:C, scaling=1.0)</code></pre><p>Generates the graph for the polynomial using Horner&#39;s method. More precisely, it corresponds to the evaluation of the polynomial</p><pre><code class="language-none">p(s) = a[1] + a[2]*(αs) + ... + a[n-1]*(αs)^(n-2) + a[n]*(αs)^(n-1),</code></pre><p>as the recursion</p><pre><code class="language-none">Cj=s*B{j+1}
Bj=a[j]*I+α*Cj,</code></pre><p>where <code>α=scaling</code>.</p><p>The kwargs <code>B</code> and <code>C</code> specifies the base-names of these intermediate variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/horner.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_horner_degopt" href="#GraphMatFun.graph_horner_degopt"><code>GraphMatFun.graph_horner_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_horner_degopt(a; scaling=1.0, input=:A)</code></pre><p>Generates a polynomial using Horner&#39;s evaluation scheme. The polynomial</p><pre><code class="language-none"> p(s) = a[1] + a[2]*(αs) + ... + a[n-1]*(αs)^(n-2) + a[n]*(αs)^(n-1),</code></pre><p>is evaluated as</p><pre><code class="language-none"> p(s) = a[1] + (αs)*(a[2] + (αs)*(... + (αs)*(a[n-1] + a[n]*(αs))...)),</code></pre><p>where α=<code>scaling</code>. However, the function uses a call to <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>, resulting in more degrees of freedom in <code>crefs</code>. See also <a href="#GraphMatFun.graph_horner"><code>graph_horner</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/horner.jl#L56-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_ps" href="#GraphMatFun.graph_ps"><code>GraphMatFun.graph_ps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_ps(a; input=:A,
                      B_base=:B, C_base=:C, P_base=:P)</code></pre><p>Generates the graph for the Paterson–Stockmeyer procedure with monomial basis coefficieents. More precisely, it corresponds to evaluation of the polynomial</p><pre><code class="language-none">p(s) = a[1] + a[2]*s + ... + a[n]*s^(n-1).</code></pre><p>The code follows the description in the second of the papers referenced below.</p><p><strong>References</strong></p><ol><li><p>M. Paterson and L. Stockmeyer. &quot;On the number of nonscalar multiplications necessary to evaluate polynomials&quot;. SIAM Journal on Scientific Computing, 2(1):60-66, 1973. DOI: <a href="https://doi.org/10.1137/0202007">10.1137/0202007</a></p></li><li><p>M. Fasi. &quot;Optimality of the Paterson–Stockmeyer method for evaluating matrix polynomials and rational matrix functions&quot;. Linear Algebra and its Applications, 574, 2019. DOI: <a href="https://doi.org/10.1016/j.laa.2019.04.001">10.1016/j.laa.2019.04.001</a></p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/ps_poly.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_ps_degopt" href="#GraphMatFun.graph_ps_degopt"><code>GraphMatFun.graph_ps_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_ps_degopt(a; input=:A)</code></pre><p>Generates the same polynomial as <a href="#GraphMatFun.graph_ps"><code>graph_ps</code></a>, i.e., the graph for the Paterson–Stockmeyer procedure with monomial basis coefficieents. However, it does so by wrapping a call to <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>, resulting in more degrees of freedom in <code>crefs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/ps_poly.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_sastre_poly" href="#GraphMatFun.graph_sastre_poly"><code>GraphMatFun.graph_sastre_poly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_sastre_poly(b)</code></pre><p>Computes the degree-8 polynomial</p><pre><code class="language-none">p(z)=b[1]+z*b[2]+z^2*b[3]+...+z^8*b[9]</code></pre><p>according to Example 3.1 in the reference.</p><p><strong>Reference</strong></p><ol><li>J. Sastre. &quot;Efficient evaluation of matrix polynomials&quot;. Linear Algebra and its Applications, 539:229-250, 2018. DOI: <a href="https://doi.org/10.1016/j.laa.2017.11.010">10.1016/j.laa.2017.11.010</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/sastre.jl#L163-L177">source</a></section></article><h2 id="Degree-optimal-polynomials"><a class="docs-heading-anchor" href="#Degree-optimal-polynomials">Degree-optimal polynomials</a><a id="Degree-optimal-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Degree-optimal-polynomials" title="Permalink"></a></h2><p>The degree-optimal polynomial is a multiplication-economic scheme for evaluating polynomials. It has the possibility to reach the highest attainable degree possible for a fixed number of multiplications, i.e., degree equal to <span>$2^m$</span> with <span>$m$</span> multiplication. However, the set of degree-optimal polynomials does not span the whole set of polynomials of degree less than or equal to <span>$2^m$</span>. Provided <a href="../optim/">optimization techniques</a> are therefore useful to achieve good approximations.</p><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.Degopt" href="#GraphMatFun.Degopt"><code>GraphMatFun.Degopt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">degopt=Degopt(x,y)
degopt=Degopt(HA,HB,y)
degopt=Degopt(graph)

struct Degopt{T}
    x::Vector{Tuple{Vector{T},Vector{T}}}
    y::Vector{T}
end</code></pre><p>Creates an object representing a degree-optimal polynomial, i.e., the coefficients in an evaluation scheme which maximizes the degree for a fixed number of multiplications. The object represents the coefficients in</p><pre><code class="language-none">A0=I
A1=A
A2=(x *A0+x *A1)(x *A0+x *A1)
A4=(x *A0+x *A1+x*A2)(x *A0+x *A1+x *A2)
A8=(x *A0+x *A1+x*A2)(x *A0+x *A1+x *A2)
 ..</code></pre><p>and</p><pre><code class="language-none">Out=y*A0+y*A1+y*A4+y*A8+y*B4...</code></pre><p>The <code>x</code>-values are given in the argument <code>x</code>, which is a <code>Vector{Tuple{Vector{T},Vector{T}}}</code>, containing the elements of each sum. The <code>y</code>-vector contains the elements to form the output. In the constructor with <code>HA</code>, <code>HB</code> and <code>y</code> the elements of <code>x</code> are stored as matrices.</p><p>The coefficients in graphs generated by <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a> can be recovered by using <code>Degopt(graph)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/degopt.jl#L10-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_degopt" href="#GraphMatFun.graph_degopt"><code>GraphMatFun.graph_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,crefs)=graph_degopt(k;T=ComplexF64,input=:A)
(graph,crefs)=graph_degopt(x,z;input=:A)
(graph,crefs)=graph_degopt(d::Degopt;input=:A)</code></pre><p>Corresponds to the (for a fixed number of multiplications) degree-optimal polynomial</p><pre><code class="language-none">B1=A
B2=(x *I+x *A)(x *I+x *A)
B3=(x *I+x *A+x*B2)(x *I+x *A+x *B2)
 ..</code></pre><p>and</p><pre><code class="language-none">Out=z*I+z*A1+z*B2+z*B3+z*B4...</code></pre><p>The <code>x</code>-values are given in the argument <code>x</code>, which is a <code>Vector{Tuple{Vector,Vector}}</code>, containing the elements of each sum. The <code>z</code>-vector contains the elements to form the output, and <code>input</code> determines the name of the matrix A above. If the parameter <code>k</code> is supplied instead of the coefficients, all coeffs will be set to one. The general recursion is given in (9) in the paper referenced below.</p><p><strong>Reference</strong></p><ol><li>P. Bader, S. Blanes, and F. Casas, &quot;Computing the matrix exponential with an optimized Taylor polynomial approximation&quot;, Mathematics, 7(12), 2019. DOI: <a href="https://doi.org/10.3390/math7121174">10.3390/math7121174</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/degopt_poly.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.grow!" href="#GraphMatFun.grow!"><code>GraphMatFun.grow!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grow!(degopt::Degopt)</code></pre><p>Increases the <a href="#GraphMatFun.Degopt"><code>Degopt</code></a> by one multiplication without modifying the function values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/degopt.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.scale!" href="#GraphMatFun.scale!"><code>GraphMatFun.scale!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scale!(degopt::Degopt,α)</code></pre><p>Effectively change a <a href="#GraphMatFun.Degopt"><code>Degopt</code></a> such that the input is scaled by <code>α</code>. If <code>p</code> is the original function, <code>p(α x)</code> will be the new function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/degopt.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.square!" href="#GraphMatFun.square!"><code>GraphMatFun.square!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">square!(degopt::Degopt)</code></pre><p>Effectively square a <a href="#GraphMatFun.Degopt"><code>Degopt</code></a> in the sense that the output is square. If <code>p</code> is the original function, <code>p(x)^2</code> will be the new function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/degopt.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalize!(degopt::Degopt,tp=:row1)</code></pre><p>Normalizes the <a href="#GraphMatFun.Degopt"><code>Degopt</code></a> coefficients, in the way specified by <code>tp</code>. If the <code>rp==:row1</code> the <code>degopt</code> will be transformed to an equivalent <a href="#GraphMatFun.Degopt"><code>Degopt</code></a> with first row equal to <code>(0 1) (0 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/degopt.jl#L185-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_degopt_coeffs" href="#GraphMatFun.get_degopt_coeffs"><code>GraphMatFun.get_degopt_coeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_degopt_coeffs(degopt) -&gt; (HA,HB,y)
get_degopt_coeffs(graph) -&gt; (HA,HB,y)</code></pre><p>Returns the coefficients of the degree-optimal polynomial using two matrices and one vectors as described in <a href="#GraphMatFun.Degopt"><code>Degopt</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/degopt.jl#L219-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_degopt_crefs" href="#GraphMatFun.get_degopt_crefs"><code>GraphMatFun.get_degopt_crefs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(x,z)=get_degopt_crefs(k)
(x,z)=get_degopt_crefs(graph)</code></pre><p>Returns linear combination references (crefs) related to <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>. Specifically <code>x</code> is a <code>Vector{Tuple{Vector{Tuple{Symbol,Int}},Vector{Tuple{Symbol,Int}}}}</code> such that <code>x[2][1]</code> corresponds to the coefficients of the left hand side of the multiplication</p><pre><code class="language-none">B2=(α_2_1 *I + α_2_2 *A)(β_2_1 *I + β_2_2 *A)</code></pre><p>i.e., the crefs corresponding to <code>[α_2_1, α_2_2]</code>. See <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>. Hence, <code>get_coeffs(graph,x[2][1])</code> returns the corresponding numerical values of the coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/degopt.jl#L93-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_topo_order_degopt" href="#GraphMatFun.get_topo_order_degopt"><code>GraphMatFun.get_topo_order_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">order=get_topo_order_degopt(k)</code></pre><p>A special implementation of <a href="../graph/#GraphMatFun.get_topo_order"><code>get_topo_order</code></a> for degree-optimal polynomials generated with <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>. The natural order of computation is to compute row by row.</p><p>See also <a href="#GraphMatFun.get_degopt_crefs"><code>get_degopt_crefs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/degopt_poly.jl#L116-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_sastre_yks_degopt" href="#GraphMatFun.graph_sastre_yks_degopt"><code>GraphMatFun.graph_sastre_yks_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_sastre_yks_degopt(k,s,c)</code></pre><p>Transforms the polynomial evaluation format given by equations (62)-(65) in the reference to <code>degop</code>-format. The <code>graph</code> is a representation of <code>y_{k,s}</code>. Input <code>c</code> is a grouping of the coefficients as given by the representation (62)-(65). <code>c</code> is a <code>Vector{Vector{Vector}}</code> of length <code>k+1</code>, representing</p><pre><code class="language-none">[
[c_i^{(0,1)}, c_i^{(0,2)}]
[c_i^{(1,1)}, c_i^{(1,2)}, c_i^{(1,3)}, c_i^{(1,4)}, c_i^{(1,5)}, c_i^{(1,6)}]
...
[c_i^{(k,1)}, c_i^{(k,2)}, c_i^{(k,3)}, c_i^{(k,4)}, c_i^{(k,5)}, c_i^{(k,6)}]
]</code></pre><p>Hence, <code>c[1]</code> contains two vectors, the first of length <code>s</code>-1 and the second of length <code>s</code>. (Note: In the first vector the constant for I is set to zero) and <code>c[2]</code> up to <code>c[k+1]</code> conatins six vectors: Even-numbered vectors have length <code>s</code>+1 Odd-numbered vectors have length j-1, where j is the intex in <code>c</code>, e.g., <code>c[2][1]</code> has one element and <code>c[3][5]</code> have two. For example, equations (57)-(59) are implemented as:</p><pre><code class="language-none">c = [
[[c15, c16], [0.0, 0, 0]], # (57)
[[1.0], [0, c13, c14], [1.0], [c11, 0, c12], [c10], [0.0, 0, 0]], # (58)
[[0.0, 1], [0, c8, c9], [c7, 1], [0, c6, 0], [c4, c5], [c1, c2, c3]], # (59)
]</code></pre><p><strong>Reference</strong></p><ol><li>J. Sastre. &quot;Efficient evaluation of matrix polynomials&quot;. Linear Algebra and its Applications, 539:229-250, 2018. DOI: <a href="https://doi.org/10.1016/j.laa.2017.11.010">10.1016/j.laa.2017.11.010</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/sastre.jl#L222-L255">source</a></section></article><h2 id="Rational-functions"><a class="docs-heading-anchor" href="#Rational-functions">Rational functions</a><a id="Rational-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Rational-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_rational" href="#GraphMatFun.graph_rational"><code>GraphMatFun.graph_rational</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph, cref) = graph_rational(den_coeffs, num_coeffs, poly_gen=graph_ps)
 (graph, cref) = graph_rational(
    den_graph,
    num_graph;
    den_cref = Vector{Tuple{Symbol,Int}}(),
    num_cref = Vector{Tuple{Symbol,Int}}(),
)</code></pre><p>Generates the graph for the rational approximation</p><pre><code class="language-none">r(A)=q(A)^{-1}p(A)</code></pre><p>where p(A) and q(A) are polynomials defined by the coefficients <code>den_coeffs</code> and <code>num_coeffs</code>, and generated by the function <code>poly_gen</code>, which is called as <code>(graph,cref)=poly_gen(coeffs)</code>, see, e.g., <a href="#GraphMatFun.graph_monomial"><code>graph_monomial</code></a> and <a href="#GraphMatFun.graph_ps"><code>graph_ps</code></a>.</p><p>The alternative call-signature involves the graphs for p and q directly, as <code>den_graph</code> and <code>num_graph</code>. The corresponding <code>den_cref</code> and <code>num_cref</code> can also be passed to be modified accordingly, otherwise the return value <code>cref</code> is empty for this call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/rational.jl#L2-L24">source</a></section></article><h2 id="Matrix-exponential"><a class="docs-heading-anchor" href="#Matrix-exponential">Matrix exponential</a><a id="Matrix-exponential-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-exponential" title="Permalink"></a></h2><p>One of the most important matrix functions is the matrix exponential. The package contains graph-representations for several of the state-of-the-art evaluation schemes.</p><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_exp_native_jl" href="#GraphMatFun.graph_exp_native_jl"><code>GraphMatFun.graph_exp_native_jl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_exp_native_jl(A; input=:A)</code></pre><p>Creates a graph for the native scaling-and-squaring for the matrix exponential, as implemented in Julia. The matrix <code>A</code> is taken as input to determine the length of the Padé approximant and the number of squares applied, as well as determining the type of the coefficients. The kwarg <code>input</code> determines the name of the matrix, in the graph.</p><p><strong>References</strong></p><ol><li><p>N. J. Higham. &quot;Functions of Matrices&quot;. SIAM, Philadelphia, PA, 2008. DOI: <a href="https://doi.org/10.1137/1.9780898717778">10.1137/1.9780898717778</a></p></li><li><p>N. J. Higham. &quot;The Scaling and Squaring Method for the Matrix Exponential Revisited&quot;. SIAM Journal on Matrix Analysis and Applications, 26(4):1179-1193, 2005. DOI: <a href="https://doi.org/10.1137/04061101X">10.1137/04061101X</a></p></li><li><p>&quot;Julia&#39;s matrix exponential&quot;, <a href="https://github.com/JuliaLang/julia/blob/697e782ab86bfcdd7fd15550241fe162c51d9f98/stdlib/LinearAlgebra/src/dense.jl#L554">at the time of conversion</a>.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/exp.jl#L54-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_exp_native_jl_degopt" href="#GraphMatFun.graph_exp_native_jl_degopt"><code>GraphMatFun.graph_exp_native_jl_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_exp_native_jl_degopt(A; input=:A)</code></pre><p>Same as <a href="#GraphMatFun.graph_exp_native_jl"><code>graph_exp_native_jl</code></a> but with calls to <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a> for contruction of numerator and denominator polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/exp.jl#L209-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_sastre_exp" href="#GraphMatFun.graph_sastre_exp"><code>GraphMatFun.graph_sastre_exp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_sastre_exp(k,method=:auto)</code></pre><p>Computes a polynomial evaluation approximating the exponential using <code>k</code> matrix multiplications following a <code>method</code> given in the reference. The schemes are embedded into <code>degop</code>-format, see <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>.</p><p>The methods are (from the paper referenced below):</p><ul><li><code>:ps_degopt</code>, Paterson–Stockmeyer method embedded into <code>degopt</code>-format.</li><li><code>:y1s</code>, given by equations (34)-(35)</li><li><code>:z1ps</code>, given by equations (34)-(35) and (52)</li><li><code>:h2m</code>, given by equations (34)-(35) and (69)</li></ul><p>Not all combinations of <code>k</code> and <code>method</code> are implemented. Available ones are:</p><ul><li><code>k&lt;3</code>, <code>method</code>=<code>:ps_degopt</code></li><li><code>k=3</code>, <code>method</code>=<code>:y1s</code>, as per Table 4 in the reference</li><li><code>k=4</code>, <code>method</code>=<code>:y1s</code></li><li><code>k=6</code>, <code>method</code>=<code>:h2m</code>, as per Table 11 in the reference</li><li><code>k=8</code>, <code>method</code>=<code>:z1ps</code>, as per Table 7 in the reference</li></ul><p>The default option <code>method=:auto</code> will choose method according to the value of <code>k</code>, as prescribed above.</p><p><strong>Reference</strong></p><ol><li>J. Sastre. &quot;Efficient evaluation of matrix polynomials&quot;. Linear Algebra and its Applications, 539:229-250, 2018. DOI: <a href="https://doi.org/10.1016/j.laa.2017.11.010">10.1016/j.laa.2017.11.010</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/sastre.jl#L3-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_sid_exp" href="#GraphMatFun.graph_sid_exp"><code>GraphMatFun.graph_sid_exp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_sid_exp(k;T=Float64)</code></pre><p>Computes a polynomial evaluation approximating the exponential using <code>k</code> matrix multiplications following the procedure in the reference. The coefficients are directly copied from the paper.</p><p>The evaluation is embedded in the degopt-format, see <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>, using the function <a href="#GraphMatFun.graph_sastre_yks_degopt"><code>graph_sastre_yks_degopt</code></a>. Moreover, for <code>k&lt;=3</code> it uses the Paterson–Stockmeyer method.</p><p><strong>Reference</strong></p><ol><li>J. Sastre, J. Ibáñez, E. Defez. &quot;Boosting the computation of the matrix exponential&quot;. Applied Mathematics of Computation, 340:206-220, 2019. DOI: <a href="https://doi.org/10.1016/j.amc.2018.08.017">10.1016/j.amc.2018.08.017</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/sid.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_bbc_exp" href="#GraphMatFun.graph_bbc_exp"><code>GraphMatFun.graph_bbc_exp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_bbc_exp(k;T=Float64)</code></pre><p>Computes a polynomial evaluation approximating the exponential using <code>k</code> matrix multiplications following the procedure in the reference. The coefficients are directly copied from the paper.</p><p>The evaluation is embedded in the <code>degopt</code>-format, see <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>, and for <code>k&lt; 3</code>, the evaluation is using the Paterson–Stockmeyer method.</p><p><strong>Reference</strong></p><ol><li>P. Bader, S. Blanes, and F. Casas. &quot;Computing the matrix exponential with an optimized Taylor polynomial approximation&quot;. Mathematics, 7(12), 2019. DOI: <a href="https://doi.org/10.3390/math7121174">10.3390/math7121174</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/bbc_exp.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_bbcs_cheb_exp" href="#GraphMatFun.graph_bbcs_cheb_exp"><code>GraphMatFun.graph_bbcs_cheb_exp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_bbcs_cheb_exp(k;T=Complex{BigFloat})</code></pre><p>Computes a polynomial evaluation approximating the exponential for skew-Hermitian matrices using <code>k</code> matrix multiplications following the procedure in the reference.</p><p>For <code>k &gt; 5</code> it resorts to scaling-and-squaring of the <code>k = 5</code> graph. The graph is in the degopt format, see <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>.</p><p><strong>Reference</strong></p><ol><li>P. Bader, S. Blanes, F. Casas, M. Seydaoglu. &quot;An efficient algorithm to compute the exponential of skew-Hermitian matrices for the time integration of the Schrödinger equation&quot;. <a href="https://arxiv.org/abs/2103.10132">arXiv:2103.10132 [math.NA]</a>, 2021.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/bbcs_cheb_exp.jl#L3-L19">source</a></section></article><h2 id="Other-matrix-functions-and-iterations"><a class="docs-heading-anchor" href="#Other-matrix-functions-and-iterations">Other matrix functions and iterations</a><a id="Other-matrix-functions-and-iterations-1"></a><a class="docs-heading-anchor-permalink" href="#Other-matrix-functions-and-iterations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_denman_beavers" href="#GraphMatFun.graph_denman_beavers"><code>GraphMatFun.graph_denman_beavers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    (graph,cref)=graph_denman_beavers(k;T=ComplexF64,cref_mode=0)</code></pre><p>Creates the graph corresponding to the Denman–Beavers iteration for the matrix square root, using k iterations. The kwarg <code>cref_mode</code> specifies if references to all X and Y (<code>cref_mode=0</code>) should be stored or just Y (<code>cref_mode=-1</code>) or just X (<code>cref_mode=1</code>).</p><p><strong>Reference</strong></p><ol><li>E. Denman and A. Beavers. &quot;The matrix sign function and computations in systems&quot;. Applied Mathematics and Computation, 2(1), 1976. DOI: <a href="https://doi.org/10.1016/0096-3003(76)90020-5">10.1016/0096-3003(76)90020-5</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/denman_beavers_gen.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_newton_schulz" href="#GraphMatFun.graph_newton_schulz"><code>GraphMatFun.graph_newton_schulz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_newton_schulz(
    k,
    T = ComplexF64;
    input = :A,
    Z = :Z,
    Q = :Q,
    V = :V,
)</code></pre><p>Does <code>k</code> iterations of the Newton–Schulz iteration for approximating the inverse of a matrix A (name given by <code>input</code>), i.e., the recursion</p><pre><code class="language-none">V_k+1 = V_k*(2*I - A*V_k),</code></pre><p>with <code>V_0=A</code>. The recursion is implemented using the graph operations</p><pre><code class="language-none">Z_i=A*V_i
Q_i=2*I-Z_i
V_{i+1}=V_i*Q_i,</code></pre><p>and the kwargs <code>Z</code>, <code>Q</code>, and <code>V</code> determines the naming of the corresponding intermediate steps.</p><p><strong>References</strong></p><ol><li><p>G. Schulz. &quot;Iterative Berechnung der reziproken Matrix&quot;. Zeitschrift für Angewandte Mathematik und Mechanik, 13:57–59, 1933. DOI: <a href="https://doi.org/10.1002/zamm.19330130111">10.1002/zamm.19330130111</a></p></li><li><p>N. J. Higham. &quot;Functions of Matrices&quot;. SIAM, Philadelphia, PA, 2008. DOI: <a href="https://doi.org/10.1137/1.9780898717778">10.1137/1.9780898717778</a></p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/newton_schulz.jl#L3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_newton_schulz_degopt" href="#GraphMatFun.graph_newton_schulz_degopt"><code>GraphMatFun.graph_newton_schulz_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_newton_schulz_degopt(k, T=ComplexF64; input=:A)</code></pre><p>Does <code>k</code> iterations of the Newton–Schulz iteration for approximating the inverse, using the recursion</p><pre><code class="language-none">Z_i=A*V_i
V_{i+1}=V_i*(2*I-Z_i).</code></pre><p>The function makes a call to <a href="#GraphMatFun.graph_degopt"><code>graph_degopt</code></a>, resulting in more degrees of freedom in <code>crefs</code>. See also <a href="#GraphMatFun.graph_newton_schulz"><code>graph_newton_schulz</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/58c20a52800729ff5c4d22c1aeca94ccccc62f53/src/generators/newton_schulz.jl#L67-L78">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../graph/">« Graphs and their manipulation</a><a class="docs-footer-nextpage" href="../optim/">Graph optimization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 11 August 2021 18:36">Wednesday 11 August 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
