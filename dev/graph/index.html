<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Graphs and their manipulation · GraphMatFun.jl</title><link rel="canonical" href="https://matrixfunctions.github.io/GraphMatFun.jl/graph/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GraphMatFun.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Graphs and their manipulation</a><ul class="internal"><li><a class="tocitem" href="#The-computational-graph-–-Compgraph"><span>The computational graph – Compgraph</span></a></li><li><a class="tocitem" href="#Manipulating-graph-topology"><span>Manipulating graph topology</span></a></li><li><a class="tocitem" href="#Evaluating-the-graph"><span>Evaluating the graph</span></a></li><li><a class="tocitem" href="#Nodes-and-coefficients"><span>Nodes and coefficients</span></a></li><li><a class="tocitem" href="#Errors-and-error-bounds"><span>Errors and error bounds</span></a></li><li><a class="tocitem" href="#Reading-and-writing-graphs-to-file"><span>Reading and writing graphs to file</span></a></li><li><a class="tocitem" href="#Helpers-and-convenience-functions"><span>Helpers and convenience functions</span></a></li></ul></li><li><a class="tocitem" href="../generators/">Built-in graphs</a></li><li><a class="tocitem" href="../optim/">Graph optimization</a></li><li><a class="tocitem" href="../code_gen/">Code generation and efficiency</a></li></ul></li><li><a class="tocitem" href="../docidx/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Graphs and their manipulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Graphs and their manipulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/master/docs/src/graph.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Graphs-and-their-manipulation"><a class="docs-heading-anchor" href="#Graphs-and-their-manipulation">Graphs and their manipulation</a><a id="Graphs-and-their-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs-and-their-manipulation" title="Permalink"></a></h1><h2 id="The-computational-graph-–-Compgraph"><a class="docs-heading-anchor" href="#The-computational-graph-–-Compgraph">The computational graph – Compgraph</a><a id="The-computational-graph-–-Compgraph-1"></a><a class="docs-heading-anchor-permalink" href="#The-computational-graph-–-Compgraph" title="Permalink"></a></h2><p>The computational graph is represented by a struct <code>Compgraph{T}</code>, where <code>T</code> is the type of the coefficients. Each node in the graph is represented by a <code>Symbol</code>, and these node-IDs need to be unique for every node.</p><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.Compgraph" href="#GraphMatFun.Compgraph"><code>GraphMatFun.Compgraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">graph=Compgraph(T::Type=ComplexF64)</code></pre><p>Creates an empty computation graph of with coefficients of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L38-L42">source</a></section><section><div><pre><code class="language-none">graph=Compgraph(T,orggraph::Compgraph)</code></pre><p>Converts a graph such that the coefficients become type <code>T</code>. Note that <code>T</code> can be a <code>Number</code> but can be other objects with defined operations, or just <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L51-L57">source</a></section></article><h2 id="Manipulating-graph-topology"><a class="docs-heading-anchor" href="#Manipulating-graph-topology">Manipulating graph topology</a><a id="Manipulating-graph-topology-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulating-graph-topology" title="Permalink"></a></h2><p>In general a graph is composed of linear combinations <span>$C = \alpha A + \beta B$</span> (<a href="#GraphMatFun.add_lincomb!"><code>add_lincomb!</code></a>), multiplication <span>$C = AB$</span> (<a href="#GraphMatFun.add_mult!"><code>add_mult!</code></a>), and left inverse <span>$C = A^{-1}B$</span>  (<a href="#GraphMatFun.add_ldiv!"><code>add_ldiv!</code></a>).</p><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.add_lincomb!" href="#GraphMatFun.add_lincomb!"><code>GraphMatFun.add_lincomb!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_lincomb!(graph,node,α1,p1,α2,p2)</code></pre><p>The operation <code>α1*p1+α2*p2</code> is added to the graph. The result is stored in node <code>node</code>.</p><p>See also <a href="#GraphMatFun.add_sum!"><code>add_sum!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L111-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.add_mult!" href="#GraphMatFun.add_mult!"><code>GraphMatFun.add_mult!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_mult!(graph,node,p1,p2)</code></pre><p>Adds a multiplication of node <code>p1</code> and <code>p2</code> to the <code>graph</code>. The result is stored in node <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.add_ldiv!" href="#GraphMatFun.add_ldiv!"><code>GraphMatFun.add_ldiv!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_ldiv!(graph,node,p1,p2)</code></pre><p>The operation <code>inv(p1)*p2</code> is added to the graph. The result is stored in node <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L127-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.add_sum!" href="#GraphMatFun.add_sum!"><code>GraphMatFun.add_sum!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cref=add_sum!(graph,node,c,nodelist,base_name=node)</code></pre><p>Adds a linear combination of more than two nodes, given in <code>nodelist::Vector</code>, with coefficients given in <code>c</code>. The <code>base_name</code> is temporary variables for the summing. The sum is stored in <code>node</code>.</p><p>Returns <code>cref</code> list with references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L241-L249">source</a></section></article><p>The graph can have multiple outputs and the behavior controlled.</p><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.add_output!" href="#GraphMatFun.add_output!"><code>GraphMatFun.add_output!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_output!(graph,node)</code></pre><p>Adds <code>node</code> to the bottom of the list of outputs of the graph.</p><p>See also <a href="#GraphMatFun.eval_graph"><code>eval_graph</code></a>, <a href="../optim/#GraphMatFun.eval_jac"><code>eval_jac</code></a>, and <a href="#GraphMatFun.eval_runerr"><code>eval_runerr</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L140-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.del_output!" href="#GraphMatFun.del_output!"><code>GraphMatFun.del_output!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">del_output!(graph,node)</code></pre><p>Removes the output <code>node</code> from the list of output nodes of the graph. This function does not remove the node from the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.clear_outputs!" href="#GraphMatFun.clear_outputs!"><code>GraphMatFun.clear_outputs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">clear_outputs!(graph)</code></pre><p>Clears the list of output nodes of the graph. This function does not remove the node nodes from the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L166-L171">source</a></section></article><p>It is also possible to merge two graphs, and to rename and delete nodes.</p><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.merge_graphs" href="#GraphMatFun.merge_graphs"><code>GraphMatFun.merge_graphs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">graph=merge_graphs(
graph1,
graph2;
prefix1 = &quot;&quot;,
prefix2 = &quot;G2&quot;,
skip_basic1 = true,
skip_basic2 = true,
cref1 = Vector(),
cref2 = Vector(),
input1 = :A,
input2 = :A,</code></pre><p>)</p><p>Takes all the nodes and edges in <code>graph1</code> and <code>graph2</code> and generates a new graph. The node names are in <code>graph1</code> are changed by adding a prefix <code>prefix1</code> and <code>graph2</code> correspondingly. The nodes <code>:I</code> and <code>:A</code> are unchanged if <code>skip_basicX=true</code>. All coefficient references <code>crefX</code> are modified accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/merge.jl#L42-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.rename_node!" href="#GraphMatFun.rename_node!"><code>GraphMatFun.rename_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rename_node!(graph,src,dest,cref=Vector())</code></pre><p>This changes the name of the node <code>src</code> to <code>dest</code> and updates all references to the node, including coefficient references in <code>cref</code> and <code>graph.outputs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.del_node!" href="#GraphMatFun.del_node!"><code>GraphMatFun.del_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">del_node!(graph,node)</code></pre><p>Deletes <code>node</code> from the graph, and all data associated with it, except for <code>graph.outputs</code>.</p><p>See <a href="#GraphMatFun.del_output!"><code>del_output!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L275-L282">source</a></section></article><h2 id="Evaluating-the-graph"><a class="docs-heading-anchor" href="#Evaluating-the-graph">Evaluating the graph</a><a id="Evaluating-the-graph-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-the-graph" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.eval_graph" href="#GraphMatFun.eval_graph"><code>GraphMatFun.eval_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">result=eval_graph(
    graph,
    x;
    vals = nothing,
    input = :A,
    output = size(graph.outputs, 1),
    comporder = nothing,
)</code></pre><p>Evaluates a graph in the value <code>x</code> which is typically a scalar value or a matrix. If <code>x</code> is a Vector, the values will be evaluated elementwise.</p><p>The <code>comporder</code> is a <code>Vector</code> of nodes specifying in which order the graph should be computed. By default <a href="#GraphMatFun.get_topo_order"><code>get_topo_order</code></a> is used.</p><p>The <code>output</code> is an <code>Int</code> specifying which node should be considered as output. The output node is <code>graph.outputs[output]</code>.</p><p>The <code>vals</code> is used to inspect contents other than the output inside the graph. Typically <code>vals</code> is a <code>Dict</code>. It will be modified to contain the computed nodes of the graph. If we wish to inspect node <code>X3</code>, we can initiate an empty dict as input:</p><pre><code class="language-julia-repl">julia &gt; vals = Dict{Symbol,Any}();
julia &gt; eval_graph(graph, A, vals = vals);
julia &gt; vals[:X3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/eval.jl#L11-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_topo_order" href="#GraphMatFun.get_topo_order"><code>GraphMatFun.get_topo_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(order,can_be_deallocated,max_nodes)=get_topo_order(
    graph;
    priohelp = Dict{Symbol,Float64}(),
    free_mem_bonus = 1000,
    will_not_dealloc = [:I],
    input = :A,
)</code></pre><p>Computes a topological sort of <code>graph</code>, that is, an ordering of the nodes following which the function the graph represents can be evaluated. The <code>priohelp</code> kwarg can be used to obtain a different topological ordering by changing the node priority. The code assumes that the nodes <code>:I</code> and <code>input</code> do not need to be computed.</p><p>The code uses a heuristic to minimize pathwidth. It is based on a point system. You can influence the computation order by providing a <code>priohelp</code>. If you want node <code>:B4</code> to be computed earlier, you can set <code>priohelp[:B4]=-5000.0</code>. The <code>free_mem_bonus</code> is used in the heuristic to prioritize the computation of nodes which release other nodes. The vector <code>will_not_deallocate</code> influences the order specifying nodes that will not be deallocated and therefore gets no <code>free_mem_bonus</code>.</p><p>The return value <code>order</code> is a <code>Vector</code> of Symbols, and <code>can_be_deallocated</code> is a <code>Vector{Vector{Symbol}}</code> where the element <code>i</code> specifies the <code>Symbols</code> that are unused after step <code>i</code> in the ordering. The <code>max_nodes</code> is the pathwidth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L428-L454">source</a></section></article><h2 id="Nodes-and-coefficients"><a class="docs-heading-anchor" href="#Nodes-and-coefficients">Nodes and coefficients</a><a id="Nodes-and-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes-and-coefficients" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_sorted_keys" href="#GraphMatFun.get_sorted_keys"><code>GraphMatFun.get_sorted_keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">v=get_sorted_keys(graph)</code></pre><p>Returns a list of all nodes, sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L316-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_all_cref" href="#GraphMatFun.get_all_cref"><code>GraphMatFun.get_all_cref</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">v=get_all_cref(graph)</code></pre><p>Returns a list with references to all coefficients in the graph. The list is sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L325-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_coeffs" href="#GraphMatFun.get_coeffs"><code>GraphMatFun.get_coeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x=get_coeffs(graph, cref=get_all_cref(graph))</code></pre><p>Gets the coefficient values for the coefficients specified in <code>cref::Vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L376-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.set_coeffs!" href="#GraphMatFun.set_coeffs!"><code>GraphMatFun.set_coeffs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_coeffs!(graph, x, cref=get_all_cref(graph))</code></pre><p>Sets the coefficient values in the coefficients specified in <code>cref::Vector</code> to the values in the vector in <code>x::Vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L342-L347">source</a></section></article><h2 id="Errors-and-error-bounds"><a class="docs-heading-anchor" href="#Errors-and-error-bounds">Errors and error bounds</a><a id="Errors-and-error-bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Errors-and-error-bounds" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.compute_bwd_theta" href="#GraphMatFun.compute_bwd_theta"><code>GraphMatFun.compute_bwd_theta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(e_bwd,theta)=compute_bwd_theta(;
    bnd_rel_err = compute_bnd_rel_bwd_err(:exp, graph),
    tolerance = eps(coefftype) / 2,
    theta_init = big&quot;0.2&quot;,
    use_log = false,
)

(e_bwd,theta)=compute_bwd_theta(
    graph::Compgraph{T};
    coefftype = T,
    numterms = 100,
    numdigits = 100,
    tolerance = eps(coefftype) / 2,
    theta_init = big&quot;0.2&quot;,
    use_log = false,
)</code></pre><p>Compute bound on relative backward error with corresponding theta.</p><p>The first output <span>$e_{bwd}$</span> is a function that returns a bound on the relative backward error of the polynomial underlying the computational graph <code>graph</code>, seen as an approximant to the exponential. For the underlying polynomial <span>$p$</span>, the function returns a bound on <code>|δ|</code> where <code>δ</code> is such that exp(z+δ) = p(z). This function is computed using <code>compute_bnd_rel_bwd_err(:graph)</code>.</p><p>The second output <span>$θ$</span> is the largest positive real number such that <span>$e_{bwd}(θ) ≤ tolerance$</span>, where <span>$tolerance$</span> is by default the unit roundoff of the data type <code>coefftype</code>, which in turn defaults to the type of the coefficients of <code>graph</code>.</p><p>The value of <span>$theta$</span> is estimated by approximately solving the equation <span>$e_{bwd}(z) = tolerance$</span>, using the built-in function <code>fzero</code> with starting value set to <code>theta_init</code>. By default this root-finding procedure uses high-precision arithmetic.</p><p>If the kwarg <code>use_log</code> is set to <code>true</code>, then the value of <span>$theta$</span> is computed by approximating a solution to the equation <span>$log(e_{bwd}(z)) = log(tolerance)$</span> instead.</p><p>The alternative form accepts a function that returns a bound on the relative backward error. By default, the function is constructed with <code>compute_bnd_rel_bwd_err(:exp, ...)</code> and the default values for the kwargs in the first form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/error_bounds.jl#L160-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.compute_fwd_theta" href="#GraphMatFun.compute_fwd_theta"><code>GraphMatFun.compute_fwd_theta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(e_fwd,theta)=compute_fwd_theta(
    graph::Compgraph{T},
    f;
    coefftype = T,
    tolerance = eps(coefftype) / 2,
    theta_init = big&quot;0.1&quot;,
)</code></pre><p>Return relative forward error and corresponding theta for approximation to <code>f</code>.</p><p>The first output <span>$e_{fwd}$</span> is the function that computes the relative forward error<span>$e_{fwd}(z)=|f(z) - p(z)| / |z|$</span>, where <span>$p$</span> is the polynomial underlying the computational graph <code>graph</code>. This is meaningful only if <span>$p$</span> approximates <span>$f$</span> in some sense.</p><p>The second output <span>$θ$</span> is the largest positive real number such that <span>$e_{fwd}(θ) ≤ tolerance$</span>, where <span>$tolerance$</span> is by default the unit roundoff of the data type <code>coefftype</code>, which in turn defaults to the type of the coefficients of <code>graph</code>.</p><p>The value of <span>$θ$</span> is approximated by using the built-in function <code>fzero</code> with starting value set to <code>theta_init</code>. By default, this root-finding procedure uses high-precision arithmetic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/error_bounds.jl#L40-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.compute_bnd_rel_bwd_err" href="#GraphMatFun.compute_bnd_rel_bwd_err"><code>GraphMatFun.compute_bnd_rel_bwd_err</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">e_bwd=compute_bnd_rel_bwd_err(
    f,
    graph::Compgraph{T};
    coefftype = T,
    numterms = 100,
    numdigits = 100,
)</code></pre><p>Compute a bound on the relative backward error of the function <code>f</code>.</p><p>The returned function <span>$e_{bwd}$</span> is a bound on the relative backward error of the polynomial underlying the computational graph <code>graph</code>, seen as an approximant to <code>f</code>. For the underlying polynomial <span>$p$</span>, the function returns a bound on <code>|δ|</code> where <code>δ</code> is such that <span>$f(z+δ) = p(z)$</span>.</p><p>The first argument <code>f</code> is a symbol. Currently supported values include:</p><ul><li><code>:exp</code> The bound is computed by means of the identity δ = log((exp(-z) p(z)-1)+1). The code computes the series expansion of the right-hand side of the equation, truncates it to the first <code>numterms</code> coefficients, bounds each coefficient of the ensuing polynomial with its absolute value. The computation uses <code>numdigits</code> digits of precision.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/error_bounds.jl#L89-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.eval_runerr" href="#GraphMatFun.eval_runerr"><code>GraphMatFun.eval_runerr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">err=eval_runerr(
    graph,
    x;
    vals = nothing,
    relerrs = nothing,
    input = :A,
    output = size(graph.outputs, 1),
    mode = :bounds, # Can be :bounds, :rand, :estimate
    add_relerr = eps(),
)</code></pre><p>Provides the running error of the graph evaluated in <code>x</code>. See <a href="#GraphMatFun.eval_graph"><code>eval_graph</code></a> for meaning of <code>vals</code> and <code>output</code>. The kwarg <code>relerrs</code> is an anologous variable for the running error estimates in each node. The kwarg <code>mode</code> can be <code>:bounds</code>, <code>:rand</code>, <code>:estimate</code>, specifying if the code should make estimates or bounds, or random error within the bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/eval.jl#L285-L302">source</a></section></article><h2 id="Reading-and-writing-graphs-to-file"><a class="docs-heading-anchor" href="#Reading-and-writing-graphs-to-file">Reading and writing graphs to file</a><a id="Reading-and-writing-graphs-to-file-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-and-writing-graphs-to-file" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.export_compgraph" href="#GraphMatFun.export_compgraph"><code>GraphMatFun.export_compgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function export_compgraph(
        graph,
    fname;
    main_output = nothing,
    order = get_topo_order(graph)[1],
    fun = &quot;&quot;,
    dom = &quot;&quot;,
    err = &quot;&quot;,
    genby = &quot;&quot;,
    descr = &quot;&quot;,
    user = splitdir(homedir())[end],
)</code></pre><p>Exports the graph to the file <code>fname</code> using the computation graph format (cgr). These kwargs are strings or values that are stored as comments in the file</p><ul><li><code>descr</code> of the graph</li><li><code>fun</code> function it approximates</li><li><code>dom</code> domain it approximates</li><li><code>err</code> error in this domain</li><li><code>genby</code> script that generated this file</li><li><code>user</code> a username that created the file</li></ul><p>These kwarg influence how the graph is stored:</p><ul><li><code>order</code> specifies an order the graph nodes are stored</li><li><code>main_output</code> is a <code>Symbol</code> specifying what is the output.</li></ul><p>CGR format:</p><p>Every line corresponds to a node / operation. The syntax is matlab compatible, although <a href="../code_gen/#GraphMatFun.gen_code"><code>gen_code</code></a> produces faster matlab code.</p><p>See also <a href="#GraphMatFun.export_compgraph"><code>export_compgraph</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct_IO.jl#L5-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.import_compgraph" href="#GraphMatFun.import_compgraph"><code>GraphMatFun.import_compgraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">graph=import_compgraph(fname)</code></pre><p>Reads a graph stored in the computation graph format (cgr) in the file <code>fname</code>.</p><p>See also <a href="#GraphMatFun.import_compgraph"><code>import_compgraph</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct_IO.jl#L143-L149">source</a></section></article><h2 id="Helpers-and-convenience-functions"><a class="docs-heading-anchor" href="#Helpers-and-convenience-functions">Helpers and convenience functions</a><a id="Helpers-and-convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helpers-and-convenience-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_polynomial" href="#GraphMatFun.get_polynomial"><code>GraphMatFun.get_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">p = get_polynomial(graph::Compgraph)</code></pre><p>Return the polynomial underlying the computational <code>graph</code>. The <code>graph</code> is assumed to involve only linear combinations and multiplications.</p><p><code>p</code> is polynomial of type <code>Polynomial</code> from the package <a href="https://juliamath.github.io/Polynomials.jl/stable/"><code>Polynomials.jl</code></a>.</p><p>See also <a href="#GraphMatFun.get_polynomial_coefficients"><code>get_polynomial_coefficients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/error_bounds.jl#L8-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_polynomial_coefficients" href="#GraphMatFun.get_polynomial_coefficients"><code>GraphMatFun.get_polynomial_coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">c = get_polynomial_coefficients(graph::Compgraph)</code></pre><p>Return the coefficients of the polynomial underlying the computational <code>graph</code>. The <code>graph</code> is assumed to involve only linear combinations and multiplications.</p><p>The coefficients <code>c</code> is a vector containing the coefficients as expressed in the monomial basis and sorted from the leading coefficient to the constant term.</p><p>See also <a href="#GraphMatFun.get_polynomial"><code>get_polynomial</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/error_bounds.jl#L25-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype" href="#Base.eltype"><code>Base.eltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">T=eltpye(graph::Compgraph{T})</code></pre><p>Returns the type <code>T</code> of a <code>graph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L395-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.big" href="#Base.big"><code>Base.big</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bgraph=big(graph::Compgraph{T})</code></pre><p>Converts the coefficients of <code>graph</code> to type <code>big(T)</code> and returns <code>bgraph</code>, which is of type <code>Compgraph{big(T)}</code>.</p><p>See also <a href="#GraphMatFun.Compgraph"><code>Compgraph(T,orggraph::Compgraph)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L75-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.complex" href="#Base.complex"><code>Base.complex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cgraph=big(graph::Compgraph{T})</code></pre><p>Converts the coefficients of <code>graph</code> to type <code>complex(T)</code> and returns <code>cgraph</code>, which is of type <code>Compgraph{complex(T)}</code>.</p><p>See also <a href="#GraphMatFun.Compgraph"><code>Compgraph(T,orggraph::Compgraph)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/89cc7e88fbb4005ac9ca2f9a979c1f77cb186d78/src/compgraph_struct.jl#L86-L93">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../generators/">Built-in graphs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 22 October 2022 19:04">Saturday 22 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
