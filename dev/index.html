<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GraphMatFun.jl</title><link rel="canonical" href="https://matrixfunctions.github.io/GraphMatFun.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GraphMatFun.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GraphMatFun"><a class="docs-heading-anchor" href="#GraphMatFun">GraphMatFun</a><a id="GraphMatFun-1"></a><a class="docs-heading-anchor-permalink" href="#GraphMatFun" title="Permalink"></a></h1><ul><li><a href="#GraphMatFun.Compgraph-Tuple{Any,Compgraph}"><code>GraphMatFun.Compgraph</code></a></li><li><a href="#GraphMatFun.Compgraph"><code>GraphMatFun.Compgraph</code></a></li><li><a href="#GraphMatFun.Degopt-Tuple{Any,Any}"><code>GraphMatFun.Degopt</code></a></li><li><a href="#GraphMatFun.LangC_MKL"><code>GraphMatFun.LangC_MKL</code></a></li><li><a href="#GraphMatFun.LangC_OpenBLAS"><code>GraphMatFun.LangC_OpenBLAS</code></a></li><li><a href="#GraphMatFun.LangJulia"><code>GraphMatFun.LangJulia</code></a></li><li><a href="#GraphMatFun.LangMatlab"><code>GraphMatFun.LangMatlab</code></a></li><li><a href="#GraphMatFun.add_ldiv!-NTuple{4,Any}"><code>GraphMatFun.add_ldiv!</code></a></li><li><a href="#GraphMatFun.add_lincomb!-NTuple{6,Any}"><code>GraphMatFun.add_lincomb!</code></a></li><li><a href="#GraphMatFun.add_mult!-NTuple{4,Any}"><code>GraphMatFun.add_mult!</code></a></li><li><a href="#GraphMatFun.add_output!-Tuple{Any,Any}"><code>GraphMatFun.add_output!</code></a></li><li><a href="#GraphMatFun.add_sum!"><code>GraphMatFun.add_sum!</code></a></li><li><a href="#GraphMatFun.adjust_for_errtype!-NTuple{4,Any}"><code>GraphMatFun.adjust_for_errtype!</code></a></li><li><a href="#GraphMatFun.clear_outputs!-Tuple{Any}"><code>GraphMatFun.clear_outputs!</code></a></li><li><a href="#GraphMatFun.compress_graph!"><code>GraphMatFun.compress_graph!</code></a></li><li><a href="#GraphMatFun.compress_graph_dangling!"><code>GraphMatFun.compress_graph_dangling!</code></a></li><li><a href="#GraphMatFun.compress_graph_output_cleaning!"><code>GraphMatFun.compress_graph_output_cleaning!</code></a></li><li><a href="#GraphMatFun.compress_graph_passthrough!"><code>GraphMatFun.compress_graph_passthrough!</code></a></li><li><a href="#GraphMatFun.compress_graph_redundant!"><code>GraphMatFun.compress_graph_redundant!</code></a></li><li><a href="#GraphMatFun.compress_graph_trivial!"><code>GraphMatFun.compress_graph_trivial!</code></a></li><li><a href="#GraphMatFun.compress_graph_zero_coeff!"><code>GraphMatFun.compress_graph_zero_coeff!</code></a></li><li><a href="#GraphMatFun.compute_bwd_theta_exponential-Union{Tuple{Compgraph{T}}, Tuple{T}} where T"><code>GraphMatFun.compute_bwd_theta_exponential</code></a></li><li><a href="#GraphMatFun.compute_fwd_theta-Union{Tuple{T}, Tuple{Compgraph{T},Any}} where T"><code>GraphMatFun.compute_fwd_theta</code></a></li><li><a href="#GraphMatFun.del_node!-Tuple{Any,Any}"><code>GraphMatFun.del_node!</code></a></li><li><a href="#GraphMatFun.del_output!-Tuple{Any,Any}"><code>GraphMatFun.del_output!</code></a></li><li><a href="#GraphMatFun.eval_graph-Tuple{Any,Any}"><code>GraphMatFun.eval_graph</code></a></li><li><a href="#GraphMatFun.eval_jac-Tuple{Any,Any,Any}"><code>GraphMatFun.eval_jac</code></a></li><li><a href="#GraphMatFun.eval_runerr-Tuple{Any,Any}"><code>GraphMatFun.eval_runerr</code></a></li><li><a href="#GraphMatFun.export_compgraph-Tuple{Any,Any}"><code>GraphMatFun.export_compgraph</code></a></li><li><a href="#GraphMatFun.extract_sums-Tuple{Any}"><code>GraphMatFun.extract_sums</code></a></li><li><a href="#GraphMatFun.gen_code-Tuple{Any,Any}"><code>GraphMatFun.gen_code</code></a></li><li><a href="#GraphMatFun.get_all_cref-Tuple{Any}"><code>GraphMatFun.get_all_cref</code></a></li><li><a href="#GraphMatFun.get_children-Tuple{Any,Any}"><code>GraphMatFun.get_children</code></a></li><li><a href="#GraphMatFun.get_coeffs"><code>GraphMatFun.get_coeffs</code></a></li><li><a href="#GraphMatFun.get_degopt_crefs-Tuple{Any}"><code>GraphMatFun.get_degopt_crefs</code></a></li><li><a href="#GraphMatFun.get_polynomial-Tuple{Compgraph}"><code>GraphMatFun.get_polynomial</code></a></li><li><a href="#GraphMatFun.get_polynomial_coefficients-Tuple{Compgraph}"><code>GraphMatFun.get_polynomial_coefficients</code></a></li><li><a href="#GraphMatFun.get_sorted_keys-Tuple{Any}"><code>GraphMatFun.get_sorted_keys</code></a></li><li><a href="#GraphMatFun.get_topo_order-Tuple{Any}"><code>GraphMatFun.get_topo_order</code></a></li><li><a href="#GraphMatFun.get_topo_order_degopt-Tuple{Any}"><code>GraphMatFun.get_topo_order_degopt</code></a></li><li><a href="#GraphMatFun.graph_bbc_exp-Tuple{Any}"><code>GraphMatFun.graph_bbc_exp</code></a></li><li><a href="#GraphMatFun.graph_bbcs_cheb_exp-Tuple{Any}"><code>GraphMatFun.graph_bbcs_cheb_exp</code></a></li><li><a href="#GraphMatFun.graph_degopt-Tuple{Any,Any}"><code>GraphMatFun.graph_degopt</code></a></li><li><a href="#GraphMatFun.graph_denman_beavers-Tuple{Any}"><code>GraphMatFun.graph_denman_beavers</code></a></li><li><a href="#GraphMatFun.graph_exp_native_jl-Tuple{Any}"><code>GraphMatFun.graph_exp_native_jl</code></a></li><li><a href="#GraphMatFun.graph_exp_native_jl_degopt-Tuple{Any}"><code>GraphMatFun.graph_exp_native_jl_degopt</code></a></li><li><a href="#GraphMatFun.graph_horner-Tuple{Any}"><code>GraphMatFun.graph_horner</code></a></li><li><a href="#GraphMatFun.graph_horner_degopt-Tuple{Any}"><code>GraphMatFun.graph_horner_degopt</code></a></li><li><a href="#GraphMatFun.graph_monomial-Tuple{Any}"><code>GraphMatFun.graph_monomial</code></a></li><li><a href="#GraphMatFun.graph_monomial_degopt-Tuple{Any}"><code>GraphMatFun.graph_monomial_degopt</code></a></li><li><a href="#GraphMatFun.graph_newton_schulz"><code>GraphMatFun.graph_newton_schulz</code></a></li><li><a href="#GraphMatFun.graph_newton_schulz_degopt"><code>GraphMatFun.graph_newton_schulz_degopt</code></a></li><li><a href="#GraphMatFun.graph_ps-Tuple{Any}"><code>GraphMatFun.graph_ps</code></a></li><li><a href="#GraphMatFun.graph_ps_degopt-Tuple{Any}"><code>GraphMatFun.graph_ps_degopt</code></a></li><li><a href="#GraphMatFun.graph_rational-Tuple{Any,Any,Any}"><code>GraphMatFun.graph_rational</code></a></li><li><a href="#GraphMatFun.graph_sastre_exp"><code>GraphMatFun.graph_sastre_exp</code></a></li><li><a href="#GraphMatFun.graph_sastre_poly-Tuple{Any}"><code>GraphMatFun.graph_sastre_poly</code></a></li><li><a href="#GraphMatFun.graph_sastre_yks_degopt-Tuple{Any,Any,Any}"><code>GraphMatFun.graph_sastre_yks_degopt</code></a></li><li><a href="#GraphMatFun.graph_sid_exp-Tuple{Any}"><code>GraphMatFun.graph_sid_exp</code></a></li><li><a href="#GraphMatFun.grow!-Union{Tuple{Degopt{T}}, Tuple{T}} where T"><code>GraphMatFun.grow!</code></a></li><li><a href="#GraphMatFun.has_identity_lincomb-Tuple{Any}"><code>GraphMatFun.has_identity_lincomb</code></a></li><li><a href="#GraphMatFun.has_trivial_nodes-Tuple{Any}"><code>GraphMatFun.has_trivial_nodes</code></a></li><li><a href="#GraphMatFun.import_compgraph-Tuple{Any}"><code>GraphMatFun.import_compgraph</code></a></li><li><a href="#GraphMatFun.merge_graphs-Tuple{Any,Any}"><code>GraphMatFun.merge_graphs</code></a></li><li><a href="#GraphMatFun.opt_gauss_newton!-Tuple{Any,Any,Any}"><code>GraphMatFun.opt_gauss_newton!</code></a></li><li><a href="#GraphMatFun.opt_linear_fit!-NTuple{4,Any}"><code>GraphMatFun.opt_linear_fit!</code></a></li><li><a href="#GraphMatFun.rename_node!"><code>GraphMatFun.rename_node!</code></a></li><li><a href="#GraphMatFun.scale!-Tuple{Degopt,Any}"><code>GraphMatFun.scale!</code></a></li><li><a href="#GraphMatFun.set_coeffs!"><code>GraphMatFun.set_coeffs!</code></a></li><li><a href="#GraphMatFun.solve_linlsqr!-NTuple{4,Any}"><code>GraphMatFun.solve_linlsqr!</code></a></li><li><a href="#GraphMatFun.square!-Tuple{Degopt}"><code>GraphMatFun.square!</code></a></li><li><a href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.Compgraph" href="#GraphMatFun.Compgraph"><code>GraphMatFun.Compgraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">graph=Compgraph(T::Type=ComplexF64)</code></pre><p>Creates an empty computation graph of with coefficients of type <code>T</code>.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.Compgraph-Tuple{Any,Compgraph}" href="#GraphMatFun.Compgraph-Tuple{Any,Compgraph}"><code>GraphMatFun.Compgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">graph=Compgraph(T,orggraph::Compgraph)</code></pre><p>Converts a graph such that the coefficients become type <code>T</code>. Note that <code>T</code> can be a <code>Number</code> but can be other objects with defined operations, or just <code>Any</code>.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.Degopt-Tuple{Any,Any}" href="#GraphMatFun.Degopt-Tuple{Any,Any}"><code>GraphMatFun.Degopt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">degopt=Degopt(x,y)
degopt=Degopt(HA,HB,y)
degopt=Degopt(graph)

struct Degopt{T}
    x::Vector{Tuple{Vector{T},Vector{T}}}
    y::Vector{T}
end</code></pre><p>Creates an object representing a degree optimal polynomial, i.e., the coefficients in an evaluation scheme which maximizes the degree for a fixed number of multiplications. The object represents the coefficients in</p><pre><code class="language-none">A0=I
A1=A
A2=(x *A0+x *A1)(x *A0+x *A1)
A4=(x *A0+x *A1+x*A2)(x *A0+x *A1+x *A2)
A8=(x *A0+x *A1+x*A2)(x *A0+x *A1+x *A2)
 ..</code></pre><p>and</p><pre><code class="language-none">Out=y*A0+y*A1+y*A4+y*A8+y*B4...</code></pre><p>The <code>x</code>-values are given in the argument <code>x</code>, which is a <code>Vector{Tuple{Vector{T},Vector{T}}}</code>, containing the elements of each sum. The <code>y</code>-vector contains the elements to form the output. In the constructor with <code>HA</code>, <code>HB</code> and <code>y</code> the elements of <code>x</code> are stored as matrices.</p><p>The coefficients in graphs generated by <a href="#GraphMatFun.graph_degopt-Tuple{Any,Any}"><code>graph_degopt</code></a> can be recovered by using <code>Degopt(graph)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/degopt.jl#L10-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.LangC_MKL" href="#GraphMatFun.LangC_MKL"><code>GraphMatFun.LangC_MKL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia"> LangC_MKL(gen_main::Bool)</code></pre><p>Code generation in C using MKL implementation of BLAS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/code_gen/gen_c_code.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.LangC_OpenBLAS" href="#GraphMatFun.LangC_OpenBLAS"><code>GraphMatFun.LangC_OpenBLAS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia"> LangC_OpenBLAS(gen_main::Bool)</code></pre><p>Code generation in C using OpenBLAS implementation of BLAS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/code_gen/gen_c_code.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.LangJulia" href="#GraphMatFun.LangJulia"><code>GraphMatFun.LangJulia</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LangJulia(overwrite_input=true,inline=true,dot_fusing=true)</code></pre><p>Code generation in julia language, with optional overwriting of input, inlining the function and optional usage of dot fusion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/code_gen/gen_julia_code.jl#L9-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.LangMatlab" href="#GraphMatFun.LangMatlab"><code>GraphMatFun.LangMatlab</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LangMatlab()</code></pre><p>Code generation for the Matlab language.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/code_gen/gen_matlab_code.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.add_ldiv!-NTuple{4,Any}" href="#GraphMatFun.add_ldiv!-NTuple{4,Any}"><code>GraphMatFun.add_ldiv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_ldiv!(graph,node,p1,p2)</code></pre><p>The operation <code>inv(p1)*p2</code> is added to the graph. The result is stored in node <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.add_lincomb!-NTuple{6,Any}" href="#GraphMatFun.add_lincomb!-NTuple{6,Any}"><code>GraphMatFun.add_lincomb!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_lincomb!(graph,node,α1,p1,α2,p2)</code></pre><p>The operation <code>α1*p1+α2*p2</code> is added to the graph. The result is stored in node <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.add_mult!-NTuple{4,Any}" href="#GraphMatFun.add_mult!-NTuple{4,Any}"><code>GraphMatFun.add_mult!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_mult!(graph,node,p1,p2)</code></pre><p>Adds a multiplication of node <code>p1</code> and <code>p2</code> to the <code>graph</code>. The result is stored in node <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.add_output!-Tuple{Any,Any}" href="#GraphMatFun.add_output!-Tuple{Any,Any}"><code>GraphMatFun.add_output!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_output!(graph,node)</code></pre><p>Adds an output <code>node</code> to the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.add_sum!" href="#GraphMatFun.add_sum!"><code>GraphMatFun.add_sum!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">crefs=add_sum!(graph,node,c,nodelist,base_name=node)</code></pre><p>Adds a linear combination of more than two nodes, given in <code>nodelist::Vector</code>, with coefficients given in <code>c</code>. The <code>base_name</code> is temporary variables for the summing. The sum is stored in <code>node</code>.</p><p>Returns cref list with references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L213-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.adjust_for_errtype!-NTuple{4,Any}" href="#GraphMatFun.adjust_for_errtype!-NTuple{4,Any}"><code>GraphMatFun.adjust_for_errtype!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adjust_for_errtype!(A, b, objfun_vals, errtype)</code></pre><p>Adjusts the matrix <code>A</code> and vector <code>b</code> to <code>errtype</code>. <code>A</code> is a matrix, e.g., the Jacobian or system matrix in a least squares problem. <code>b</code> is a vector, e.g., the residuals or the right-hand side in a lieast squares problem. <code>objfun_vals</code> is a vector of objective function values, and <code>errtype</code> can be <code>:abserr</code> or <code>:relerr</code>, i.e., absolute error or relative error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/optimization/opt_common.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.clear_outputs!-Tuple{Any}" href="#GraphMatFun.clear_outputs!-Tuple{Any}"><code>GraphMatFun.clear_outputs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_outputs!(graph)</code></pre><p>Clears the list of output nodes of the graph. This function does not remove the node nodes from the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L138-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.compress_graph!" href="#GraphMatFun.compress_graph!"><code>GraphMatFun.compress_graph!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compress_graph!(graph,cref=[];verbose=false)</code></pre><p>Searches for nodes which can be removed or reorganized without changing the function it represents. Corresponding references in the <code>cref</code>-vector are removed.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compress_graph.jl#L395-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.compress_graph_dangling!" href="#GraphMatFun.compress_graph_dangling!"><code>GraphMatFun.compress_graph_dangling!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compress_graph_dangling!(graph,cref=[];verbose=false)</code></pre><p>Removes dangling nodes in the graph. If a node is not used anywhere and it is not in the output, it can safely be removed.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compress_graph.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.compress_graph_output_cleaning!" href="#GraphMatFun.compress_graph_output_cleaning!"><code>GraphMatFun.compress_graph_output_cleaning!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compress_graph_output_cleaning!(graph,cref=[];verbose=false)</code></pre><p>Checks if the output is computed from the linear combination that can be compressed.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compress_graph.jl#L131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.compress_graph_passthrough!" href="#GraphMatFun.compress_graph_passthrough!"><code>GraphMatFun.compress_graph_passthrough!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compress_graph_passthrough!(graph,cref=[];verbose=false);</code></pre><p>Identifies lincombs that have coefficients (0 1) or (1 0) which correspond to identity operations. It redirect appropriately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compress_graph.jl#L349-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.compress_graph_redundant!" href="#GraphMatFun.compress_graph_redundant!"><code>GraphMatFun.compress_graph_redundant!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compress_graph_redundant!(graph,compress_lincomb=false,cref=[];verbose=false)</code></pre><p>Removes from the graph redundant nodes, that is, nodes that repeat a computaion that is already present in the graph. Nodes corresponding to a linear combination are removed only if the coefficients are the same and <code>compress_lincomb</code> is set to <code>true</code>.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compress_graph.jl#L322-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.compress_graph_trivial!" href="#GraphMatFun.compress_graph_trivial!"><code>GraphMatFun.compress_graph_trivial!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compress_graph_trivial!(graph,cref=[];verbose=false)</code></pre><p>Removes from the graph trivial nodes, that is, multiplications by the identity or linear systems whose coefficient is the identity matrix.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compress_graph.jl#L241-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.compress_graph_zero_coeff!" href="#GraphMatFun.compress_graph_zero_coeff!"><code>GraphMatFun.compress_graph_zero_coeff!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compress_graph_zero_coeff!(graph,cref=[];droptol=0;verbose=false)</code></pre><p>Searches for linear combinations with zero coeff value and tries to compress by redirecting node references.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compress_graph.jl#L69-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.compute_bwd_theta_exponential-Union{Tuple{Compgraph{T}}, Tuple{T}} where T" href="#GraphMatFun.compute_bwd_theta_exponential-Union{Tuple{Compgraph{T}}, Tuple{T}} where T"><code>GraphMatFun.compute_bwd_theta_exponential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(e_bwd,theta)=compute_bwd_theta_exponential(graph::Compgraph{T},
                                            nterms=100,
                                            ndigits=100,
                                            coefftype=T,
                                            tolerance=eps(coefftype)/2,
                                            theta_init=big&quot;0.1&quot;) where T</code></pre><p>Bound on relative backward error of the exponential with corresponding theta.</p><p>The first output <span>$e_{bwd}$</span> is the function that computes a bound on the relative backward error of the polynomial underlying the computational graph <code>graph</code>, seen as an approximant to the exponential. In other words, for the underlying polynomial <span>$p$</span> function returns a bound on <code>|δ|</code> where <code>δ</code> is such that exp(z+δ) = p(z).</p><p>The bound is computed by means of the identity δ = log((exp(-z) p(z)-1)+1). The code computes the series expansion of the right-hand side of the equation, truncates it to the first <code>nterms</code> coefficients, bounds each coefficient of the ensuing polynomial with its absolute value. The computation uses <code>ndigits</code> digits of precision.</p><p>The second output <span>$θ$</span> is the largest positive real number such that  <span>$e_{bwd}(θ) ≤ tolerance$</span>, where <span>$tolerance$</span> is by default the unit  roundoff of the data type <code>coefftype</code>, which in turn defaults to the type of  the coefficients of <code>graph</code>.</p><p>The value of <span>$theta$</span> is approximated by using the built-in function <code>fzero</code>  with starting value set to <code>theta_init</code>. By default this root-finding procedure  uses high-precision arithmetic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/error_bounds.jl#L72-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.compute_fwd_theta-Union{Tuple{T}, Tuple{Compgraph{T},Any}} where T" href="#GraphMatFun.compute_fwd_theta-Union{Tuple{T}, Tuple{Compgraph{T},Any}} where T"><code>GraphMatFun.compute_fwd_theta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(e_fwd,theta)=compute_fwd_theta(graph::Compgraph{T},f;
                                coefftype=T,
                                tolerance=eps(coefftype)/2
                                theta_init=big&quot;0.1&quot;) where T</code></pre><p>Return relative forward error and corresponding theta for approximation to <code>f</code>.</p><p>The first output <span>$e_{fwd}$</span> is the function that computes the relative forward error<span>$e_{fwd}(z)=|f(z) - p(z)| / |z|$</span>, where <span>$p$</span> is the polynomial underlying the computational graph <code>graph</code>. This is meaningful only if <span>$p$</span> is approximates <span>$f$</span> in some sense.</p><p>The second output <span>$θ$</span> is the largest positive real number such that  <span>$e_{fwd}(θ) ≤ tolerance$</span>, where <span>$tolerance$</span> is by default the unit  roundoff of the data type <code>coefftype</code>, which in turn defaults to the type of  the coefficients of <code>graph</code>.</p><p>The value of <span>$θ$</span> is approximated by using the built-in function <code>fzero</code> with  starting value set to <code>theta_init</code>. By default, this root-finding procedure  uses high-precision arithmetic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/error_bounds.jl#L29-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.del_node!-Tuple{Any,Any}" href="#GraphMatFun.del_node!-Tuple{Any,Any}"><code>GraphMatFun.del_node!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">del_node!(graph,node)</code></pre><p>Deletes a node from the graph, and all data associated with it, except for <code>graph.outputs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L253-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.del_output!-Tuple{Any,Any}" href="#GraphMatFun.del_output!-Tuple{Any,Any}"><code>GraphMatFun.del_output!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">del_output!(graph,node)</code></pre><p>Removes the output <code>node</code> from the list of output nodes of the graph. This function does not remove the node from the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.eval_graph-Tuple{Any,Any}" href="#GraphMatFun.eval_graph-Tuple{Any,Any}"><code>GraphMatFun.eval_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">result=eval_graph(graph, x; vals=nothing,
                  input=:A, output=size(graph.outputs,1),
                  comporder=nothing)</code></pre><p>Evaluates a graph in the value <code>x</code> which is typically a scalar value or a matrix. If <code>x</code> is a Vector, the values will be evaluated  elementwise.</p><p>The <code>comporder</code> is a <code>Vector</code> of nodes specifying in which order the graph should be computed. By default <code>get_topo_order</code> is used.</p><p>The <code>output</code> is an <code>Int</code> specifying which node should be considered as output. The output node is <code>graph.outputs[output]</code>.</p><p>The <code>vals</code> is used to inspect contents other than the output inside the graph. Typically <code>vals</code> is a <code>Dict</code>. It will be modified to contain the computed nodes of the graph. If we wish to inspect node <code>X3</code>, we can initiate an empty dict as input:</p><pre><code class="language-julia-repl">julia&gt; vals=Dict{Symbol,Any}();
julia&gt; eval_graph(graph,A,vals=vals);
julia&gt; vals[:X3]
</code></pre><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/eval.jl#L12-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.eval_jac-Tuple{Any,Any,Any}" href="#GraphMatFun.eval_jac-Tuple{Any,Any,Any}"><code>GraphMatFun.eval_jac</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">J=eval_jac(graph,x, cref; vals=nothing,
           input=:A, output=size(graph.outputs,1))</code></pre><p>Computes Jacobian <code>J = dZ(x_i)/dc</code>, with respect to the coefficients given in the vector <code>cref</code>, and points <code>x[1],...,x[end]</code>. See <code>eval_graph</code> for  description of <code>vals</code> and <code>output</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/eval.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.eval_runerr-Tuple{Any,Any}" href="#GraphMatFun.eval_runerr-Tuple{Any,Any}"><code>GraphMatFun.eval_runerr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">err=eval_runerr(graph, x; vals=nothing, relerrs=nothing,
                       input=:A,output=size(graph.outputs,1),
                       mode=:bounds,
                       add_relerr=eps())</code></pre><p>Provides the running error of the graph evaluated in <code>x</code>. See <code>eval_graph</code> for meaning of <code>vals</code> and <code>output</code>. The kwarg <code>relerrs</code> is an anologous variable for the running error estimates in each node. The kwarg <code>mode</code> can be <code>:bounds</code>, <code>:rand</code>, <code>:estimate</code>, specifying if the code should make estimates or bounds, or random error within the bound.</p><pre><code class="language-none"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/eval.jl#L233-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.export_compgraph-Tuple{Any,Any}" href="#GraphMatFun.export_compgraph-Tuple{Any,Any}"><code>GraphMatFun.export_compgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">export_compgraph(graph, fname; main_output=nothing,
                 order=get_topo_order(graph)[1],
                 fun=&quot;&quot;, dom=&quot;&quot;, err=&quot;&quot;, genby=&quot;&quot;,
                 descr=&quot;&quot;,
                 user=current user)</code></pre><p>Exports the graph to the file <code>fname</code> using the computation graph format (cgr). These kwargs are strings or values that are stored as comments in the file</p><ul><li><code>descr</code> of the graph</li><li><code>fun</code> function it approximates</li><li><code>dom</code> domain it approximates</li><li><code>err</code> error in this domain</li><li><code>genby</code> script that generated this file</li><li><code>user</code> a username that created the file</li></ul><p>These kwarg influence how the graph is stored:</p><ul><li><code>order</code> specifies an order the graph nodes are stored</li><li><code>main_output</code> is a <code>Symbol</code> specifying what is the output.</li></ul><p>CGR format:</p><p>Every line corresponds to a node / operation. The syntax is matlab compatible, although <code>gen_code</code> produces faster matlab code.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct_IO.jl#L5-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.extract_sums-Tuple{Any}" href="#GraphMatFun.extract_sums-Tuple{Any}"><code>GraphMatFun.extract_sums</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">v=extract_sums(graph)</code></pre><p>::Vector{Tuple{Vector{Float64},Vector{Symbol},Vector{Symbol}}}`</p><p>Returns a representation of sums in <code>graph</code> which may potentially be merged. The vector <code>sums</code> contains a tuple for each of these sums. The three entries of the tuple are:</p><ul><li>a vector of <code>Float64</code> values that represent the coefficients of the summands;</li><li>a vector of <code>Symbol</code>s that correspond to the summands; and</li><li>a vector of intermediate <code>Symbol</code>s (i.e, nodes) that can be merged.</li></ul><p>The first two vectors have the same number of entries, one for each element that can be merged in the sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L334-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.gen_code-Tuple{Any,Any}" href="#GraphMatFun.gen_code-Tuple{Any,Any}"><code>GraphMatFun.gen_code</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gen_code(fname,graph; priohelp=Dict{Symbol,Float64}(),
         lang=LangJulia(),funname=&quot;dummy&quot;,precomputed_nodes=[:A])</code></pre><p>Generates the code for the <code>graph</code> in the language  specified in <code>lang</code> and writes it into the file <code>fname</code>. The string <code>funname</code> is the function name. Topological order of the nodes is comptued using <code>get_topo_order</code> and <code>priohelp</code> can be used to influence the order. The nodes listed in <code>precomputed_nodes</code> are viewed as inputs, and code to compute these nodes are not computed.</p><p>Currently supported languages: <code>LangC_MKL</code>, <code>LangC_OpenBLAS</code>,  <code>LangJulia</code>, <code>LangMatlab</code>, <code>LangDegoptJulia</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/code_gen/gen_code.jl#L63-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_all_cref-Tuple{Any}" href="#GraphMatFun.get_all_cref-Tuple{Any}"><code>GraphMatFun.get_all_cref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">v=get_all_cref(graph)</code></pre><p>Returns a list with references to all coefficients in the graph. The list is sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L318-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_children-Tuple{Any,Any}" href="#GraphMatFun.get_children-Tuple{Any,Any}"><code>GraphMatFun.get_children</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> children=get_children(graph,node)</code></pre><p>Returns the (direct) children of <code>node</code>.</p><pre><code class="language-none"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L510-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_coeffs" href="#GraphMatFun.get_coeffs"><code>GraphMatFun.get_coeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">x=get_coeffs(graph, cref=get_all_cref(graph))</code></pre><p>Gets the coefficient values for the coefficients specified in <code>cref::Vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L488-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_degopt_crefs-Tuple{Any}" href="#GraphMatFun.get_degopt_crefs-Tuple{Any}"><code>GraphMatFun.get_degopt_crefs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(x,z)=get_degopt_crefs(k)
(x,z)=get_degopt_crefs(graph)</code></pre><p>Retruns crefs related to <code>graph_degopt</code>. Specifically <code>x</code> is a <code>Vector{Tuple{Vector{Tuple{Symbol,Int}},Vector{Tuple{Symbol,Int}}}}</code> such that <code>x[2][1]</code> corresponds to the coefficients of the left hand side of the multiplication</p><pre><code class="language-none">B2=(α_2_1 *I + α_2_2 *A)(β_2_1 *I + β_2_2 *A)</code></pre><p>i.e., the crefs corresponding to <code>[α_2_1, α_2_2]</code>. See <code>graph_degopt</code>. Hence, <code>get_coeffs(graph,x[2][1])</code> returns the corresponding numerical values of the coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/degopt.jl#L97-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_polynomial-Tuple{Compgraph}" href="#GraphMatFun.get_polynomial-Tuple{Compgraph}"><code>GraphMatFun.get_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_polynomial(graph::Compgraph)</code></pre><p>Return the polynomial underlying the computational graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/error_bounds.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_polynomial_coefficients-Tuple{Compgraph}" href="#GraphMatFun.get_polynomial_coefficients-Tuple{Compgraph}"><code>GraphMatFun.get_polynomial_coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_polynomial_coefficients(graph::Compgraph)</code></pre><p>Return the coefficients of the polynomial underlying the computational graph. The coefficients are expressed in the monomial basis and sorted from the leading coefficient to the constant term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/error_bounds.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_sorted_keys-Tuple{Any}" href="#GraphMatFun.get_sorted_keys-Tuple{Any}"><code>GraphMatFun.get_sorted_keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">v=get_sorted_keys(graph)</code></pre><p>Returns a list of all nodes, sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L309-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_topo_order-Tuple{Any}" href="#GraphMatFun.get_topo_order-Tuple{Any}"><code>GraphMatFun.get_topo_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(order,can_be_deallocated,max_nodes)=get_topo_order(graph; priohelp=Dict{Symbol,Float64}(),free_mem_bonus=1000,will_not_deallocate=[:I],input=:A)</code></pre><p>Computes a topological sort of <code>graph</code>, that is, an ordering of the nodes following which the function the graph represents can be evaluated. The <code>priohelp</code> kwarg can be used to obtain a different topological ordering by changing the node priority. The code assumes that the nodes <code>:I</code> and <code>input</code> do not need to be computed.</p><p>The code uses a heuristic to minimize pathwidth. It is based on a point system. You can influence the computation order by providing a <code>priohelp</code>. If you want node <code>:B4</code> to be computed earlier,  you can set <code>priohelp[:B4]=-5000.0</code>.  The <code>free_mem_bonus</code> is used in the heuristic to prioritize the computation of nodes which release other nodes. The vector <code>will_not_deallocate</code> influences the order specifying nodes that will not be deallocated and therefore gets no <code>free_mem_bonus</code>.</p><p>The return value <code>order</code> is a <code>Vector</code> of Symbols, and <code>can_be_deallocated</code> is a <code>Vector{Vector{Symbol}}</code> where the element <code>i</code> specifies the <code>Symbols</code> that are unused after step <code>i</code> in the ordering. The <code>max_nodes</code> is the pathwidth.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L537-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.get_topo_order_degopt-Tuple{Any}" href="#GraphMatFun.get_topo_order_degopt-Tuple{Any}"><code>GraphMatFun.get_topo_order_degopt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">order=get_topo_order_degopt(k)</code></pre><p>A special implementation of <code>get_topo_order</code> for degree optimal polynomials generated with <code>graph_degopt</code>. The natural order of computation is to compute row by row. See also <code>get_degopt_crefs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/degopt_poly.jl#L117-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_bbc_exp-Tuple{Any}" href="#GraphMatFun.graph_bbc_exp-Tuple{Any}"><code>GraphMatFun.graph_bbc_exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_bbc_exp(k;T=Float64)</code></pre><p>Computes a polynomial evaluation approximating the exponential using <code>k</code> matrix multiplications following the procedure in the reference. The coefficients are directly copied from the paper.</p><p>The evaluation is embedded in the <code>degopt</code>-format, and for <code>k</code>&lt;3, the evaluation is using the Paterson–Stockmeyer method.</p><p>Reference:</p><ul><li><p>Computing the matrix exponential with an optimized Taylor polynomial approximation, P. Bader, S. Blanes, and F. Casas, Mathematics, 7(12), 2019.</p><pre><code class="language-none"></code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/bbc_exp.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_bbcs_cheb_exp-Tuple{Any}" href="#GraphMatFun.graph_bbcs_cheb_exp-Tuple{Any}"><code>GraphMatFun.graph_bbcs_cheb_exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_bbcs_cheb_exp(k;T=Complex{BigFloat})</code></pre><p>Computes a polynomial evaluation approximating the exponential for skew-Hermitian matrices using <code>k</code> matrix multiplications following the procedure in the reference.</p><p>For <code>k</code> &gt; 5 it resorts to scaling-and-squaring of the <code>k</code> = 5 graph. The graph is in the degopt format.</p><p>Reference:</p><ul><li><p>An efficient algorithm to compute the exponential of skew-Hermitian matrices for the time integration of the Schrödinger equation, P. Bader, S. Blanes, F. Casas, M. Seydaoglu, arXiv:2103.10132</p><pre><code class="language-none"></code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/bbcs_cheb_exp.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_degopt-Tuple{Any,Any}" href="#GraphMatFun.graph_degopt-Tuple{Any,Any}"><code>GraphMatFun.graph_degopt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(graph,crefs)=graph_degopt(k;T=ComplexF64,input=:A)
(graph,crefs)=graph_degopt(x,z;input=:A)
(graph,crefs)=graph_degopt(d::Degopt;input=:A)</code></pre><p>Corresponds to the (for a fixed numer of multiplications) degree-optimal polynomial</p><pre><code class="language-none">B1=A
B2=(x *I+x *A)(x *I+x *A)
B3=(x *I+x *A+x*B2)(x *I+x *A+x *B2)
 ..</code></pre><p>and</p><pre><code class="language-none">Out=z*I+z*A1+z*B2+z*B3+z*B4...</code></pre><p>The <code>x</code>-values are given in the argument <code>x</code>, which is a <code>Vector{Tuple{Vector,Vector}}</code>, containing the elements of each sum. The <code>z</code>-vector contains the elements to form the output, and <code>input</code> determines the name of the matrix A above. If the parameter <code>k</code> is supplied instead of the coefficients, all coeffs will be set to one.</p><p>Reference: The general recursion is mentioned in equation (9) in this paper:</p><ul><li>Computing the matrix exponential with an optimized Taylor polynomial approximation, P. Bader, S. Blanes, and F. Casas, Mathematics, 7(12), 2019.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/degopt_poly.jl#L4-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_denman_beavers-Tuple{Any}" href="#GraphMatFun.graph_denman_beavers-Tuple{Any}"><code>GraphMatFun.graph_denman_beavers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    (graph,cref)=graph_denman_beavers(k;T=ComplexF64,cref_mode=0)</code></pre><p>Creates the graph corresponding to the Denman-Beavers iteration for the matrix square root, using k iterations. The kwarg <code>cref_mode</code> specifies if references to all X and Y (<code>cref_mode=0</code>) should be stored or just Y (<code>cref_mode=-1</code>) or just X (<code>cref_mode=1</code>).</p><p>Reference:</p><ul><li>The matrix sign function and computations in systems, E. Denman,  A. Beavers, Applied Mathematics and Computation, 2(1), 1976, https://doi.org/10.1016/0096-3003(76)90020-5</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/denman_beavers_gen.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_exp_native_jl-Tuple{Any}" href="#GraphMatFun.graph_exp_native_jl-Tuple{Any}"><code>GraphMatFun.graph_exp_native_jl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_exp_native_jl(A; input=:A)</code></pre><p>Creates a graph for the native scaling-and-squaring for the matrix exponential, as implemented in Julia. The matrix <code>A</code> is taken as input to determine the length of the Padé approximant and the number of squares applied, as well as determining the type of the coefficients. The kwarg <code>input</code> determines the name of the matrix, in the graph.</p><p>References:</p><ul><li><p>N. J. Higham. Functions of Matrices. SIAM publications, Philadelphia, PA, 2008.</p></li><li><p>N. J. Higham. The Scaling and Squaring Method for the Matrix Exponential Revisited. SIAM J. Matrix Anal. Appl., 2005 26:4, 1179-1193</p></li><li><p>Julia&#39;s matrix exponential, at the time of conversion: https://github.com/JuliaLang/julia/blob/697e782ab86bfcdd7fd15550241fe162c51d9f98/stdlib/LinearAlgebra/src/dense.jl#L554</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/exp.jl#L29-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_exp_native_jl_degopt-Tuple{Any}" href="#GraphMatFun.graph_exp_native_jl_degopt-Tuple{Any}"><code>GraphMatFun.graph_exp_native_jl_degopt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_exp_native_jl_degopt(A; input=:A)</code></pre><p>Same as <code>graph_exp_native_jl</code> but with calls to <code>graph_degopt</code> for contruction of numerator and denominator polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/exp.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_horner-Tuple{Any}" href="#GraphMatFun.graph_horner-Tuple{Any}"><code>GraphMatFun.graph_horner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_horner(a; input=:A, B=:B, C=:C, scaling=1.0)</code></pre><p>Generates the graph for the polynomial using Horner&#39;s method. More precisely, it corresponds to the evaluation of the polynomial</p><pre><code class="language-none">p(s) = a[1] + a[2]*(αs) + ... + a[n-1]*(αs)^(n-2) + a[n]*(αs)^(n-1),</code></pre><p>as the recursion</p><pre><code class="language-none">Cj=s*B{j+1}
Bj=a[j]*I+α*Cj,</code></pre><p>where α=<code>scaling</code>.</p><p>The kwargs <code>B</code> and <code>C</code> specifies the base-names of these intermediate variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/horner.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_horner_degopt-Tuple{Any}" href="#GraphMatFun.graph_horner_degopt-Tuple{Any}"><code>GraphMatFun.graph_horner_degopt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_horner_degopt(a; scaling=1.0, input=:A)</code></pre><p>Generates a polynomial using Horner&#39;s evaluation scheme. The polynomial</p><pre><code class="language-none"> p(s) = a[1] + a[2]*(αs) + ... + a[n-1]*(αs)^(n-2) + a[n]*(αs)^(n-1),</code></pre><p>is evaluated as</p><pre><code class="language-none"> p(s) = a[1] + (αs)*(a[2] + (αs)*(... + (αs)*(a[n-1] + a[n]*(αs))...)),</code></pre><p>where α=<code>scaling</code>. However, the function uses a call to <code>graph_degopt</code>, resulting in more degrees of freedom in <code>crefs</code>. See also <code>graph_horner</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/horner.jl#L59-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_monomial-Tuple{Any}" href="#GraphMatFun.graph_monomial-Tuple{Any}"><code>GraphMatFun.graph_monomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_monomial(a; input=:A, polyname=:P)</code></pre><p>Generates the graph for the polynomial using the monomial basis coefficients. More precisely, it corresponds to the evaluation of the polynomial</p><pre><code class="language-none">p(s) = a[1] + a[2]*s + ... + a[n]*s^(n-1),</code></pre><p>where s^k is naively evaluated as s^k=s*s^(k-1) for k=2,3,...,n-1. The kwarg <code>polyname</code> specifies the name of intermediate variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/monomial_poly.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_monomial_degopt-Tuple{Any}" href="#GraphMatFun.graph_monomial_degopt-Tuple{Any}"><code>GraphMatFun.graph_monomial_degopt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_monomial_degopt(a; input=:A)</code></pre><p>Generates the same polynomial as <code>graph_monomial</code>, in the monomial basis. However, it does so by wrapping a call to <code>graph_degopt</code>, resulting in more degrees of freedom in <code>crefs</code>.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/monomial_poly.jl#L55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_newton_schulz" href="#GraphMatFun.graph_newton_schulz"><code>GraphMatFun.graph_newton_schulz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_newton_schulz(k, T=ComplexF64; input=:A, B=:B, C=:C, V=:V)</code></pre><p>Does <code>k</code> iterations of the Newton–Schulz iteration for approximating the inverse of a matrix A (name given by <code>input</code>), i.e., the recursion</p><pre><code class="language-none">V_k+1 = V_k*(2*I - A*V_k),</code></pre><p>with V_0=A. The recursion is implemented using the graph-operations</p><pre><code class="language-none">Z_i=A*V_i
Q_i=2*I-Z_i
V_{i+1}=V_i*Q_i,</code></pre><p>and the kwargs  <code>Z</code>, <code>Q</code>, and <code>V</code> determines the naming of the corresponding intermediate steps.</p><p>References:</p><ul><li><p>Günther Schulz. Iterative Berechnung der reziproken Matrix. Z. Angew. Math. Mech., 13:57–59, 1933.</p></li><li><p>N. J. Higham. Functions of Matrices. SIAM publications, Philadelphia, PA, 2008.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/newton_schulz.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_newton_schulz_degopt" href="#GraphMatFun.graph_newton_schulz_degopt"><code>GraphMatFun.graph_newton_schulz_degopt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_newton_schulz_degopt(k, T=ComplexF64; input=:A)</code></pre><p>Does <code>k</code> iterations of the Newton–Schulz iteration for approximating the inverse, using the recursion</p><pre><code class="language-none">Z_i=A*V_i
V_{i+1}=V_i*(2*I-Z_i).</code></pre><p>The function makes a call to <code>graph_degopt</code>, resulting in more degrees of freedom in <code>crefs</code>. See also <code>graph_newton_schulz</code>.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/newton_schulz.jl#L54-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_ps-Tuple{Any}" href="#GraphMatFun.graph_ps-Tuple{Any}"><code>GraphMatFun.graph_ps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_ps(a; input=:A,
                      B_base=:B, C_base=:C, P_base=:P)</code></pre><p>Generates the graph for the Paterson–Stockmeyer procedure with monomial basis coefficieents. More precily, it corresponds to evaluation of the polynomial</p><pre><code class="language-none">p(s) = a[1] + a[2]*s + ... + a[n]*s^(n-1).</code></pre><p>Reference:</p><ul><li>On the number of nonscalar multiplications necessary to evaluate polynomials, M. Paterson, L. Stockmeyer, SIAM J. Comput., 2(1), 1973.</li></ul><p>The code follows the description in:</p><ul><li><p>Optimality of the Paterson–Stockmeyer method for evaluating matrix polynomials and rational matrix functions, M. Fasi, Linear Algebra Appl., 574, 2019.</p><pre><code class="language-none"></code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/ps_poly.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_ps_degopt-Tuple{Any}" href="#GraphMatFun.graph_ps_degopt-Tuple{Any}"><code>GraphMatFun.graph_ps_degopt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> (graph,crefs)=graph_ps_degopt(a; input=:A)</code></pre><p>Generates the same polynomial as <code>graph_ps</code>, i.e., the graph for the Paterson–Stockmeyer procedure with monomial basis coefficieents. However, it does so by wrapping a call to <code>graph_degopt</code>, resulting in more degrees of freedom in <code>crefs</code>.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/ps_poly.jl#L140-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_rational-Tuple{Any,Any,Any}" href="#GraphMatFun.graph_rational-Tuple{Any,Any,Any}"><code>GraphMatFun.graph_rational</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> (graph, cref) = graph_rational(den_coeffs, num_coeffs, poly_gen=graph_ps)
 (graph, cref) = graph_rational(den_graph, den_graph; den_cref=Vector{Tuple{Symbol,Int}}(), num_cref=Vector{Tuple{Symbol,Int}}())</code></pre><p>Generates the graph for the rational approximation</p><pre><code class="language-none">r(A)=q(A)^{-1}p(A)</code></pre><p>where p(A) and q(A) are polynomials defined by the coeficients <code>den_coeffs</code> and <code>num_coeffs</code>, and generated by the function <code>poly_gen</code>, which is called as (graph,cref)=poly<em>gen(coeffs), see, e.g., `graph</em>monomial<code>and</code>graph_ps`.</p><p>The alternative call-signature involves the graphs for p and q directly, as <code>den_graph</code> and <code>num_graph</code>. The corresponding <code>den_cref</code> and <code>num_cref</code> can also be passed to be modified accodringly, otherwise the return value <code>cref</code> is empty for this call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/rational.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_sastre_exp" href="#GraphMatFun.graph_sastre_exp"><code>GraphMatFun.graph_sastre_exp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_sastre_exp(k,method=:auto)</code></pre><p>Computes a polynomial evaluation approximating the exponential using <code>k</code> matrix multiplications following a <code>method</code> given in the reference. The schemes are embedded into <code>degop</code>-format.</p><p>Methods are:</p><ul><li><code>:ps_degopt</code>, Paterson–Stockmeyer method embedded into <code>degopt</code>-format.</li><li><code>:y1s</code>, given by equations (34)-(35)</li><li><code>:z1ps</code>, given by equations (34)-(35) and (52)</li><li><code>:h2m</code>, given by equations (34)-(35) and (69)</li></ul><p>Not all combinations of <code>k</code> and <code>method</code> are implemented. Available ones are:</p><ul><li><code>k</code>&lt;3, <code>method</code>=<code>:ps_degopt</code></li><li><code>k</code>=3, <code>method</code>=<code>:y1s</code>, as per Table 4 in the reference</li><li><code>k</code>=4, <code>method</code>=<code>:y1s</code></li><li><code>k</code>=6, <code>method</code>=<code>:h2m</code>, as per Table 11 in the reference</li><li><code>k</code>=8, <code>method</code>=<code>:z1ps</code>, as per Table 7 in the reference</li></ul><p>The default option <code>method=:auto</code> will choose method according to the value of <code>k</code>, as prescribed above.</p><p>Reference:</p><ul><li>Efficient evaluation of matrix polynomials, J. Sastre. Linear Algebra and its Applications ,Volume 539, 2018, Pages 229-250, https://doi.org/10.1016/j.laa.2017.11.010</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/sastre.jl#L4-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_sastre_poly-Tuple{Any}" href="#GraphMatFun.graph_sastre_poly-Tuple{Any}"><code>GraphMatFun.graph_sastre_poly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_sastre_poly(b)</code></pre><p>Computes the degree-8 polynomial</p><pre><code class="language-none">p(z)=b[1]+z*b[2]+z^2*b[3]+...+z^8*b[9]</code></pre><p>according to Example 3.1 in the reference.</p><p>Reference:</p><ul><li>Efficient evaluation of matrix polynomials, J. Sastre. Linear Algebra and its Applications ,Volume 539, 2018, Pages 229-250, https://doi.org/10.1016/j.laa.2017.11.010</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/sastre.jl#L162-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_sastre_yks_degopt-Tuple{Any,Any,Any}" href="#GraphMatFun.graph_sastre_yks_degopt-Tuple{Any,Any,Any}"><code>GraphMatFun.graph_sastre_yks_degopt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_sastre_yks_degopt(k,s,c)</code></pre><p>Transforms the polynomial evaluation format given by equations (62)-(65) in the reference to <code>degop</code>-format. The <code>graph</code> is a representation of y_{<code>k</code> <code>s</code>}. Input <code>c</code> is a grouping of the coefficients as given by the representation (62)-(65). <code>c</code> is a <code>Vector{Vector{Vector}}</code> of length <code>k</code>+1, representing</p><pre><code class="language-none">[
[c_i^{(0,1)}, c_i^{(0,2)}]
[c_i^{(1,1)}, c_i^{(1,2)}, c_i^{(1,3)}, c_i^{(1,4)}, c_i^{(1,5)}, c_i^{(1,6)}]
...
[c_i^{(k,1)}, c_i^{(k,2)}, c_i^{(k,3)}, c_i^{(k,4)}, c_i^{(k,5)}, c_i^{(k,6)}]
]</code></pre><p>Hence, <code>c[1]</code> contains two vectors, the first of length <code>s</code>-1 and the second of length <code>s</code>. (Note: In the first vector the constant for I is set to zero) and <code>c[2]</code> up to <code>c[k+1]</code> conatins six vectors: Even-numbered vectors have length <code>s</code>+1 Odd-numbered vectors have length j-1, where j is the intex in <code>c</code>, e.g., <code>c[2][1]</code> has one element and <code>c[3][5]</code> have two. For example, equations (57)-(59) are implemented as:</p><pre><code class="language-none">c = [
[[c15, c16], [0.0, 0, 0]], # (57)
[[1.0], [0, c13, c14], [1.0], [c11, 0, c12], [c10], [0.0, 0, 0]], # (58)
[[0.0, 1], [0, c8, c9], [c7, 1], [0, c6, 0], [c4, c5], [c1, c2, c3]], # (59)
]</code></pre><p>Reference:</p><ul><li>Efficient evaluation of matrix polynomials, J. Sastre. Linear Algebra and its Applications ,Volume 539, 2018, Pages 229-250, https://doi.org/10.1016/j.laa.2017.11.010</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/sastre.jl#L218-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.graph_sid_exp-Tuple{Any}" href="#GraphMatFun.graph_sid_exp-Tuple{Any}"><code>GraphMatFun.graph_sid_exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(graph,cref)=graph_sid_exp(k;T=Float64)</code></pre><p>Computes a polynomial evaluation approximating the exponential using <code>k</code> matrix multiplications following the procedure in the reference. The coefficients are directly copied from the paper.</p><p>The evaluation is embedded in the <code>degopt</code>-format, using the function <code>graph_sastre_yks_degopt</code>. Moreover, for <code>k</code>&lt;=3 it uses the Paterson–Stockmeyer method.</p><p>Reference:</p><ul><li><p>Boosting the computation of the matrix exponential, J. Sastre, J. Ibáñez, E. Defez, Appl. Math. Computation, 340, 2019, 206-220.</p><pre><code class="language-none"></code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/generators/sid.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.grow!-Union{Tuple{Degopt{T}}, Tuple{T}} where T" href="#GraphMatFun.grow!-Union{Tuple{Degopt{T}}, Tuple{T}} where T"><code>GraphMatFun.grow!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grow!(degopt::Degopt)</code></pre><p>Increases the degopt by one multiplication without modifying the function values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/degopt.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.has_identity_lincomb-Tuple{Any}" href="#GraphMatFun.has_identity_lincomb-Tuple{Any}"><code>GraphMatFun.has_identity_lincomb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_identity_lincomb(graph) -&gt; Bool</code></pre><p>Checks whether the graph has a node which is a linear combination of identity matrices.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compress_graph.jl#L205-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.has_trivial_nodes-Tuple{Any}" href="#GraphMatFun.has_trivial_nodes-Tuple{Any}"><code>GraphMatFun.has_trivial_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_trivial_node(graph) -&gt; Bool</code></pre><p>Checks whether the graph has trivial nodes, that is, multiplications by the identity or linear systems whose coefficient is the identity matrix.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compress_graph.jl#L223-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.import_compgraph-Tuple{Any}" href="#GraphMatFun.import_compgraph-Tuple{Any}"><code>GraphMatFun.import_compgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">graph=import_compgraph(fname)</code></pre><p>Reads a graph stored in the computation graph format (cgr) in the file <code>fname</code>.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct_IO.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.merge_graphs-Tuple{Any,Any}" href="#GraphMatFun.merge_graphs-Tuple{Any,Any}"><code>GraphMatFun.merge_graphs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">graph=merge_graphs(graph1,graph2;prefix1=&quot;&quot;,prefix2=&quot;G2&quot;,skip_basic1=true,skip_basic2=true,cref1=Vector(),cref2=Vector(),input1=:A,input2=:A)</code></pre><p>Takes all the nodes and edges in <code>graph1</code> and <code>graph2</code> and generates a new graph. The node names are in <code>graph1</code> are changed by adding a prefix <code>prefix1</code> and <code>graph2</code> correspondingly. The nodes <code>:I</code> and <code>:A</code> are unchanged if <code>skip_basicX=true</code>. All coefficient references <code>crefX</code> are modified accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/merge.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.opt_gauss_newton!-Tuple{Any,Any,Any}" href="#GraphMatFun.opt_gauss_newton!-Tuple{Any,Any,Any}"><code>GraphMatFun.opt_gauss_newton!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(iter,resnorm)=opt_gauss_newton!(graph, objfun, discr; maxit = 100, logger = 0,
                                 errtype = :abserr, stoptol = 1e-6,
                                 input=:A, cref = get_all_cref(graph),
                                 γ0 = 1.0, linlsqr = :backslash, droptol = 0)</code></pre><p>Applies the Gauss–Newton algorithm to solve the nonlinear least squares problem: Fit the output of the <code>graph</code> to the values of <code>objfun</code>, in the points <code>discr</code>.</p><p>The variable <code>graph</code> is modified during the iterations. The function returns the iteration <code>iter</code> where it terminated, and the corresponding residual norm <code>resnorm</code>.</p><p>The kwargs are as follows: <code>maxit</code> determines the maximum number of iterations. If <code>logger</code> has a value &gt;0, then the intermediate results are printed. <code>errtype</code> determines the error type measured, see <code>adjust_for_errtype!</code>. <code>stoptol</code> is the corresponding stopping tolerence. <code>cref</code> is a <code>Vector{Tuple{Symbol,Int}}</code> that determines which coefficients of <code>graph</code> that are considered free variables and optimized. <code>input</code> is the label corresponding to the input node of the graph. The stepsize can be scaled with <code>γ0</code>. <code>linlsqr</code> and <code>droptol</code> determines how the inner linear least squares problem is solved; see <code>solve_linlsqr!</code>.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/optimization/gauss_newton.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.opt_linear_fit!-NTuple{4,Any}" href="#GraphMatFun.opt_linear_fit!-NTuple{4,Any}"><code>GraphMatFun.opt_linear_fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">opt_linear_fit!(graph, objfun, discr, linear_cref;
                input = :A,
                errtype = :abserr,
                linlsqr = :backslash,
                droptol = 0)</code></pre><p>Linear fitting of a <code>graph</code> of the form</p><pre><code class="language-none">c_1 g_1(x) + c_2 g_2(x) + … + c_n g_n(x)</code></pre><p>to the values of <code>objfun</code>, in the points <code>discr</code>. Reference to the coefficients <code>c_1,…,c_n</code> should be given <code>linear_cref</code>.</p><p>The variable <code>graph</code> is modified during the iterations and the function has no return value.</p><p>See <code>opt_gauss_newton!</code> for a description the kwarg <code>errtype</code> and <code>input</code>, and <code>solve_linlsqr!</code> for the kwargs <code>linlsqr and</code>droptol`.</p><p></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/optimization/linear_fit.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.rename_node!" href="#GraphMatFun.rename_node!"><code>GraphMatFun.rename_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rename_node!(graph,src,dest,cref=Vector())</code></pre><p>This changes the name of the node <code>src</code> to <code>dest</code> and updating all references to the node including coefficient references in <code>cref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L148-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.scale!-Tuple{Degopt,Any}" href="#GraphMatFun.scale!-Tuple{Degopt,Any}"><code>GraphMatFun.scale!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scale!(degopt::Degopt,α)</code></pre><p>Effectively change a <code>Degopt</code> such that the input is scaled by <code>α</code>. If <code>p</code> is the original function, <code>p(α x)</code> will be the new function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/degopt.jl#L152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.set_coeffs!" href="#GraphMatFun.set_coeffs!"><code>GraphMatFun.set_coeffs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_coeffs!(graph, x, cref=get_all_cref(graph))</code></pre><p>Sets the coefficient values in the coefficients specified in <code>cref::Vector</code> to the values in the vector in <code>x::Vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/compgraph_struct.jl#L460-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.solve_linlsqr!-NTuple{4,Any}" href="#GraphMatFun.solve_linlsqr!-NTuple{4,Any}"><code>GraphMatFun.solve_linlsqr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">d = solve_linlsqr!(A, b, linlsqr, droptol)</code></pre><p>Solves the linear least squares problem</p><pre><code class="language-none">Ad=b.</code></pre><p>The argument <code>linlsqr</code> determines how the linear least squares problem is solved. It can be <code>:backslash</code>, <code>:real_backslash</code>, <code>:nrmeq</code>, <code>:real_nrmeq</code>, <code>:svd</code>, or <code>:real_svd</code>. For the latter two options singular values below <code>droptol</code> are disregarded. The <code>:real_X</code> options optimizes <code>d</code> in the space of real vectors. The input matrix <code>A</code> is sometimes overwritten.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/optimization/opt_common.jl#L30-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GraphMatFun.square!-Tuple{Degopt}" href="#GraphMatFun.square!-Tuple{Degopt}"><code>GraphMatFun.square!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">square!(degopt::Degopt)</code></pre><p>Effectively square a <code>Degopt</code> in the sense that the output is square. If <code>p</code> is the original function, <code>p(x)^2</code> will be the new function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/degopt.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalize!(degopt,tp=:row1)</code></pre><p>Normalizes the degopt coefficients, in the way specified by <code>tp</code>. If the <code>rp==:row1</code> the degopt will be transformed to an equivalent degopt with first row equal to <code>(0 1) (0 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matrixfunctions/GraphMatFun.jl/blob/6b33f387737abaa29d0f791bbc326ceb83026d8e/src/degopt.jl#L191-L198">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 29 June 2021 09:00">Tuesday 29 June 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
