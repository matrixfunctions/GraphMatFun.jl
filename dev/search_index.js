var documenterSearchIndex = {"docs":
[{"location":"docidx/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"docidx/","page":"Index","title":"Index","text":"","category":"page"},{"location":"graph/#Graphs-and-their-manipulation","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"Compgraph","category":"page"},{"location":"graph/#GraphMatFun.Compgraph","page":"Graphs and their manipulation","title":"GraphMatFun.Compgraph","text":"graph=Compgraph(T::Type=ComplexF64)\n\nCreates an empty computation graph of with coefficients of type T.\n\n\n\n\n\n\n\ngraph=Compgraph(T,orggraph::Compgraph)\n\nConverts a graph such that the coefficients become type T. Note that T can be a Number but can be other objects with defined operations, or just Any.\n\n\n\n\n\n\n\n","category":"type"},{"location":"graph/#Manipulating-graph-topology","page":"Graphs and their manipulation","title":"Manipulating graph topology","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"add_mult!\nadd_lincomb!\nadd_ldiv!\nadd_sum!\nadd_output!\ndel_output!\nclear_outputs!\nrename_node!\ndel_node!\nmerge_graphs","category":"page"},{"location":"graph/#GraphMatFun.add_mult!","page":"Graphs and their manipulation","title":"GraphMatFun.add_mult!","text":"add_mult!(graph,node,p1,p2)\n\nAdds a multiplication of node p1 and p2 to the graph. The result is stored in node node.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.add_lincomb!","page":"Graphs and their manipulation","title":"GraphMatFun.add_lincomb!","text":"add_lincomb!(graph,node,α1,p1,α2,p2)\n\nThe operation α1*p1+α2*p2 is added to the graph. The result is stored in node node.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.add_ldiv!","page":"Graphs and their manipulation","title":"GraphMatFun.add_ldiv!","text":"add_ldiv!(graph,node,p1,p2)\n\nThe operation inv(p1)*p2 is added to the graph. The result is stored in node node.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.add_sum!","page":"Graphs and their manipulation","title":"GraphMatFun.add_sum!","text":"cref=add_sum!(graph,node,c,nodelist,base_name=node)\n\nAdds a linear combination of more than two nodes, given in nodelist::Vector, with coefficients given in c. The base_name is temporary variables for the summing. The sum is stored in node.\n\nReturns cref list with references.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.add_output!","page":"Graphs and their manipulation","title":"GraphMatFun.add_output!","text":"add_output!(graph,node)\n\nAdds an output node to the graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.del_output!","page":"Graphs and their manipulation","title":"GraphMatFun.del_output!","text":"del_output!(graph,node)\n\nRemoves the output node from the list of output nodes of the graph. This function does not remove the node from the graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.clear_outputs!","page":"Graphs and their manipulation","title":"GraphMatFun.clear_outputs!","text":"clear_outputs!(graph)\n\nClears the list of output nodes of the graph. This function does not remove the node nodes from the graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.rename_node!","page":"Graphs and their manipulation","title":"GraphMatFun.rename_node!","text":"rename_node!(graph,src,dest,cref=Vector())\n\nThis changes the name of the node src to dest and updating all references to the node including coefficient references in cref.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.del_node!","page":"Graphs and their manipulation","title":"GraphMatFun.del_node!","text":"del_node!(graph,node)\n\nDeletes a node from the graph, and all data associated with it, except for graph.outputs.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.merge_graphs","page":"Graphs and their manipulation","title":"GraphMatFun.merge_graphs","text":"graph=merge_graphs(graph1,graph2;prefix1=\"\",prefix2=\"G2\",skip_basic1=true,skip_basic2=true,cref1=Vector(),cref2=Vector(),input1=:A,input2=:A)\n\nTakes all the nodes and edges in graph1 and graph2 and generates a new graph. The node names are in graph1 are changed by adding a prefix prefix1 and graph2 correspondingly. The nodes :I and :A are unchanged if skip_basicX=true. All coefficient references crefX are modified accordingly.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Evaluating-the-graph","page":"Graphs and their manipulation","title":"Evaluating the graph","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"eval_graph\nget_topo_order","category":"page"},{"location":"graph/#GraphMatFun.eval_graph","page":"Graphs and their manipulation","title":"GraphMatFun.eval_graph","text":"result=eval_graph(graph, x; vals=nothing,\n                  input=:A, output=size(graph.outputs,1),\n                  comporder=nothing)\n\nEvaluates a graph in the value x which is typically a scalar value or a matrix. If x is a Vector, the values will be evaluated  elementwise.\n\nThe comporder is a Vector of nodes specifying in which order the graph should be computed. By default get_topo_order is used.\n\nThe output is an Int specifying which node should be considered as output. The output node is graph.outputs[output].\n\nThe vals is used to inspect contents other than the output inside the graph. Typically vals is a Dict. It will be modified to contain the computed nodes of the graph. If we wish to inspect node X3, we can initiate an empty dict as input:\n\njulia> vals=Dict{Symbol,Any}();\njulia> eval_graph(graph,A,vals=vals);\njulia> vals[:X3]\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.get_topo_order","page":"Graphs and their manipulation","title":"GraphMatFun.get_topo_order","text":"(order,can_be_deallocated,max_nodes)=get_topo_order(graph; priohelp=Dict{Symbol,Float64}(),free_mem_bonus=1000,will_not_deallocate=[:I],input=:A)\n\nComputes a topological sort of graph, that is, an ordering of the nodes following which the function the graph represents can be evaluated. The priohelp kwarg can be used to obtain a different topological ordering by changing the node priority. The code assumes that the nodes :I and input do not need to be computed.\n\nThe code uses a heuristic to minimize pathwidth. It is based on a point system. You can influence the computation order by providing a priohelp. If you want node :B4 to be computed earlier,  you can set priohelp[:B4]=-5000.0.  The free_mem_bonus is used in the heuristic to prioritize the computation of nodes which release other nodes. The vector will_not_deallocate influences the order specifying nodes that will not be deallocated and therefore gets no free_mem_bonus.\n\nThe return value order is a Vector of Symbols, and can_be_deallocated is a Vector{Vector{Symbol}} where the element i specifies the Symbols that are unused after step i in the ordering. The max_nodes is the pathwidth.\n\n\n\n\n\n\n\n","category":"function"},{"location":"graph/#Nodes-and-coefficients","page":"Graphs and their manipulation","title":"Nodes and coefficients","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"get_sorted_keys\nget_all_cref\nget_coeffs\nset_coeffs!","category":"page"},{"location":"graph/#GraphMatFun.get_sorted_keys","page":"Graphs and their manipulation","title":"GraphMatFun.get_sorted_keys","text":"v=get_sorted_keys(graph)\n\nReturns a list of all nodes, sorted.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.get_all_cref","page":"Graphs and their manipulation","title":"GraphMatFun.get_all_cref","text":"v=get_all_cref(graph)\n\nReturns a list with references to all coefficients in the graph. The list is sorted.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.get_coeffs","page":"Graphs and their manipulation","title":"GraphMatFun.get_coeffs","text":"x=get_coeffs(graph, cref=get_all_cref(graph))\n\nGets the coefficient values for the coefficients specified in cref::Vector.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.set_coeffs!","page":"Graphs and their manipulation","title":"GraphMatFun.set_coeffs!","text":"set_coeffs!(graph, x, cref=get_all_cref(graph))\n\nSets the coefficient values in the coefficients specified in cref::Vector to the values in the vector in x::Vector.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Errors-and-error-bounds","page":"Graphs and their manipulation","title":"Errors and error bounds","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"compute_fwd_theta\ncompute_bwd_theta_exponential\neval_runerr","category":"page"},{"location":"graph/#GraphMatFun.compute_fwd_theta","page":"Graphs and their manipulation","title":"GraphMatFun.compute_fwd_theta","text":"(e_fwd,theta)=compute_fwd_theta(graph::Compgraph{T},f;\n                                coefftype=T,\n                                tolerance=eps(coefftype)/2\n                                theta_init=big\"0.1\") where T\n\nReturn relative forward error and corresponding theta for approximation to f.\n\nThe first output e_fwd is the function that computes the relative forward errore_fwd(z)=f(z) - p(z)  z, where p is the polynomial underlying the computational graph graph. This is meaningful only if p is approximates f in some sense.\n\nThe second output θ is the largest positive real number such that  e_fwd(θ)  tolerance, where tolerance is by default the unit  roundoff of the data type coefftype, which in turn defaults to the type of  the coefficients of graph.\n\nThe value of θ is approximated by using the built-in function fzero with  starting value set to theta_init. By default, this root-finding procedure  uses high-precision arithmetic.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.compute_bwd_theta_exponential","page":"Graphs and their manipulation","title":"GraphMatFun.compute_bwd_theta_exponential","text":"(e_bwd,theta)=compute_bwd_theta_exponential(graph::Compgraph{T},\n                                            nterms=100,\n                                            ndigits=100,\n                                            coefftype=T,\n                                            tolerance=eps(coefftype)/2,\n                                            theta_init=big\"0.1\") where T\n\nBound on relative backward error of the exponential with corresponding theta.\n\nThe first output e_bwd is the function that computes a bound on the relative backward error of the polynomial underlying the computational graph graph, seen as an approximant to the exponential. In other words, for the underlying polynomial p function returns a bound on |δ| where δ is such that exp(z+δ) = p(z).\n\nThe bound is computed by means of the identity δ = log((exp(-z) p(z)-1)+1). The code computes the series expansion of the right-hand side of the equation, truncates it to the first nterms coefficients, bounds each coefficient of the ensuing polynomial with its absolute value. The computation uses ndigits digits of precision.\n\nThe second output θ is the largest positive real number such that  e_bwd(θ)  tolerance, where tolerance is by default the unit  roundoff of the data type coefftype, which in turn defaults to the type of  the coefficients of graph.\n\nThe value of theta is approximated by using the built-in function fzero  with starting value set to theta_init. By default this root-finding procedure  uses high-precision arithmetic.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.eval_runerr","page":"Graphs and their manipulation","title":"GraphMatFun.eval_runerr","text":"err=eval_runerr(graph, x; vals=nothing, relerrs=nothing,\n                       input=:A,output=size(graph.outputs,1),\n                       mode=:bounds,\n                       add_relerr=eps())\n\nProvides the running error of the graph evaluated in x. See eval_graph for meaning of vals and output. The kwarg relerrs is an anologous variable for the running error estimates in each node. The kwarg mode can be :bounds, :rand, :estimate, specifying if the code should make estimates or bounds, or random error within the bound.\n\n\n\n\n\n\n\n","category":"function"},{"location":"graph/#Reading-and-writing-graphs-to-file","page":"Graphs and their manipulation","title":"Reading and writing graphs to file","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"export_compgraph\nimport_compgraph","category":"page"},{"location":"graph/#GraphMatFun.export_compgraph","page":"Graphs and their manipulation","title":"GraphMatFun.export_compgraph","text":"export_compgraph(graph, fname; main_output=nothing,\n                 order=get_topo_order(graph)[1],\n                 fun=\"\", dom=\"\", err=\"\", genby=\"\",\n                 descr=\"\",\n                 user=current user)\n\nExports the graph to the file fname using the computation graph format (cgr). These kwargs are strings or values that are stored as comments in the file\n\ndescr of the graph\nfun function it approximates\ndom domain it approximates\nerr error in this domain\ngenby script that generated this file\nuser a username that created the file\n\nThese kwarg influence how the graph is stored:\n\norder specifies an order the graph nodes are stored\nmain_output is a Symbol specifying what is the output.\n\nCGR format:\n\nEvery line corresponds to a node / operation. The syntax is matlab compatible, although gen_code produces faster matlab code.\n\nSee also export_compgraph.\n\n\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.import_compgraph","page":"Graphs and their manipulation","title":"GraphMatFun.import_compgraph","text":"graph=import_compgraph(fname)\n\nReads a graph stored in the computation graph format (cgr) in the file fname.\n\nSee also import_compgraph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Helpers-and-convenience-functions","page":"Graphs and their manipulation","title":"Helpers and convenience functions","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"get_polynomial\nget_polynomial_coefficients\neltype\nbig\ncomplex","category":"page"},{"location":"graph/#GraphMatFun.get_polynomial","page":"Graphs and their manipulation","title":"GraphMatFun.get_polynomial","text":"get_polynomial(graph::Compgraph)\n\nReturn the polynomial underlying the computational graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.get_polynomial_coefficients","page":"Graphs and their manipulation","title":"GraphMatFun.get_polynomial_coefficients","text":"get_polynomial_coefficients(graph::Compgraph)\n\nReturn the coefficients of the polynomial underlying the computational graph. The coefficients are expressed in the monomial basis and sorted from the leading coefficient to the constant term.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Base.eltype","page":"Graphs and their manipulation","title":"Base.eltype","text":"T=eltpye(graph::Compgraph{T})\n\nReturns the type T of a graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Base.big","page":"Graphs and their manipulation","title":"Base.big","text":"bgraph=big(graph::Compgraph{T})\n\nConverts the coefficients of graph to type big(T) and returns bgraph, which is of type Compgraph{big(T)}.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Base.complex","page":"Graphs and their manipulation","title":"Base.complex","text":"cgraph=big(graph::Compgraph{T})\n\nConverts the coefficients of graph to type complex(T) and returns cgraph, which is of type Compgraph{complex(T)}.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#Code-generation-and-efficiency","page":"Code generation and efficiency","title":"Code generation and efficiency","text":"","category":"section"},{"location":"code_gen/#Improving-graph-topology","page":"Code generation and efficiency","title":"Improving graph topology","text":"","category":"section"},{"location":"code_gen/","page":"Code generation and efficiency","title":"Code generation and efficiency","text":"extract_sums\nhas_trivial_nodes\nhas_identity_lincomb\ncompress_graph! \ncompress_graph_output_cleaning!\ncompress_graph_dangling!\ncompress_graph_redundant!\ncompress_graph_trivial!\ncompress_graph_zero_coeff!\ncompress_graph_passthrough!","category":"page"},{"location":"code_gen/#GraphMatFun.extract_sums","page":"Code generation and efficiency","title":"GraphMatFun.extract_sums","text":"v=extract_sums(graph)\n\n::Vector{Tuple{Vector{Float64},Vector{Symbol},Vector{Symbol}}}`\n\nReturns a representation of sums in graph which may potentially be merged. The vector sums contains a tuple for each of these sums. The three entries of the tuple are:\n\na vector of Float64 values that represent the coefficients of the summands;\na vector of Symbols that correspond to the summands; and\na vector of intermediate Symbols (i.e, nodes) that can be merged.\n\nThe first two vectors have the same number of entries, one for each element that can be merged in the sum.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.has_trivial_nodes","page":"Code generation and efficiency","title":"GraphMatFun.has_trivial_nodes","text":"has_trivial_node(graph) -> Bool\n\nChecks whether the graph has trivial nodes, that is, multiplications by the identity or linear systems whose coefficient is the identity matrix.\n\n\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.has_identity_lincomb","page":"Code generation and efficiency","title":"GraphMatFun.has_identity_lincomb","text":"has_identity_lincomb(graph) -> Bool\n\nChecks whether the graph has a node which is a linear combination of identity matrices.\n\n\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.compress_graph!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph!","text":"compress_graph!(graph,cref=[];verbose=false)\n\nSearches for nodes which can be removed or reorganized without changing the function it represents. Corresponding references in the cref-vector are removed.\n\n\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.compress_graph_output_cleaning!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph_output_cleaning!","text":"compress_graph_output_cleaning!(graph,cref=[];verbose=false)\n\nChecks if the output is computed from the linear combination that can be compressed.\n\n\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.compress_graph_dangling!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph_dangling!","text":"compress_graph_dangling!(graph,cref=[];verbose=false)\n\nRemoves dangling nodes in the graph. If a node is not used anywhere and it is not in the output, it can safely be removed.\n\n\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.compress_graph_redundant!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph_redundant!","text":"compress_graph_redundant!(graph,compress_lincomb=false,cref=[];verbose=false)\n\nRemoves from the graph redundant nodes, that is, nodes that repeat a computaion that is already present in the graph. Nodes corresponding to a linear combination are removed only if the coefficients are the same and compress_lincomb is set to true.\n\n\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.compress_graph_trivial!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph_trivial!","text":"compress_graph_trivial!(graph,cref=[];verbose=false)\n\nRemoves from the graph trivial nodes, that is, multiplications by the identity or linear systems whose coefficient is the identity matrix.\n\n\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.compress_graph_zero_coeff!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph_zero_coeff!","text":"compress_graph_zero_coeff!(graph,cref=[];droptol=0;verbose=false)\n\nSearches for linear combinations with zero coeff value and tries to compress by redirecting node references.\n\n\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.compress_graph_passthrough!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph_passthrough!","text":"compress_graph_passthrough!(graph,cref=[];verbose=false);\n\nIdentifies lincombs that have coefficients (0 1) or (1 0) which correspond to identity operations. It redirect appropriately.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#Code-generation","page":"Code generation and efficiency","title":"Code generation","text":"","category":"section"},{"location":"code_gen/","page":"Code generation and efficiency","title":"Code generation and efficiency","text":"gen_code\nLangJulia\nLangMatlab\nLangC_MKL\nLangC_OpenBLAS","category":"page"},{"location":"code_gen/#GraphMatFun.gen_code","page":"Code generation and efficiency","title":"GraphMatFun.gen_code","text":"gen_code(fname,graph; priohelp=Dict{Symbol,Float64}(),\n         lang=LangJulia(),funname=\"dummy\",precomputed_nodes=[:A])\n\nGenerates the code for the graph in the language  specified in lang and writes it into the file fname. The string funname is the function name. Topological order of the nodes is comptued using get_topo_order and priohelp can be used to influence the order. The nodes listed in precomputed_nodes are viewed as inputs, and code to compute these nodes are not computed.\n\nCurrently supported languages: LangC_MKL, LangC_OpenBLAS,  LangJulia, LangMatlab.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.LangJulia","page":"Code generation and efficiency","title":"GraphMatFun.LangJulia","text":"LangJulia(overwrite_input=true,inline=true,dot_fusing=true)\n\nCode generation in julia language, with optional overwriting of input, inlining the function and optional usage of dot fusion.\n\n\n\n\n\n","category":"type"},{"location":"code_gen/#GraphMatFun.LangMatlab","page":"Code generation and efficiency","title":"GraphMatFun.LangMatlab","text":"LangMatlab()\n\nCode generation for the Matlab language.\n\n\n\n\n\n","category":"type"},{"location":"code_gen/#GraphMatFun.LangC_MKL","page":"Code generation and efficiency","title":"GraphMatFun.LangC_MKL","text":" LangC_MKL(gen_main::Bool)\n\nCode generation in C using MKL implementation of BLAS.\n\n\n\n\n\n","category":"type"},{"location":"code_gen/#GraphMatFun.LangC_OpenBLAS","page":"Code generation and efficiency","title":"GraphMatFun.LangC_OpenBLAS","text":" LangC_OpenBLAS(gen_main::Bool)\n\nCode generation in C using OpenBLAS implementation of BLAS.\n\n\n\n\n\n","category":"type"},{"location":"generators/#Built-in-graphs","page":"Built-in graphs","title":"Built-in graphs","text":"","category":"section"},{"location":"generators/#Polynomails","page":"Built-in graphs","title":"Polynomails","text":"","category":"section"},{"location":"generators/","page":"Built-in graphs","title":"Built-in graphs","text":"graph_monomial\ngraph_monomial_degopt\ngraph_horner\ngraph_horner_degopt\ngraph_ps\ngraph_ps_degopt\ngraph_sastre_poly","category":"page"},{"location":"generators/#GraphMatFun.graph_monomial","page":"Built-in graphs","title":"GraphMatFun.graph_monomial","text":" (graph,crefs)=graph_monomial(a; input=:A, polyname=:P)\n\nGenerates the graph for the polynomial using the monomial basis coefficients. More precisely, it corresponds to the evaluation of the polynomial\n\np(s) = a[1] + a[2]*s + ... + a[n]*s^(n-1),\n\nwhere s^k is naively evaluated as s^k=s*s^(k-1) for k=2,3,...,n-1. The kwarg polyname specifies the name of intermediate variables.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_monomial_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_monomial_degopt","text":" (graph,crefs)=graph_monomial_degopt(a; input=:A)\n\nGenerates the same polynomial as graph_monomial, in the monomial basis. However, it does so by wrapping a call to graph_degopt, resulting in more degrees of freedom in crefs.\n\n\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_horner","page":"Built-in graphs","title":"GraphMatFun.graph_horner","text":" (graph,crefs)=graph_horner(a; input=:A, B=:B, C=:C, scaling=1.0)\n\nGenerates the graph for the polynomial using Horner's method. More precisely, it corresponds to the evaluation of the polynomial\n\np(s) = a[1] + a[2]*(αs) + ... + a[n-1]*(αs)^(n-2) + a[n]*(αs)^(n-1),\n\nas the recursion\n\nCj=s*B{j+1}\nBj=a[j]*I+α*Cj,\n\nwhere α=scaling.\n\nThe kwargs B and C specifies the base-names of these intermediate variables.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_horner_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_horner_degopt","text":" (graph,crefs)=graph_horner_degopt(a; scaling=1.0, input=:A)\n\nGenerates a polynomial using Horner's evaluation scheme. The polynomial\n\n p(s) = a[1] + a[2]*(αs) + ... + a[n-1]*(αs)^(n-2) + a[n]*(αs)^(n-1),\n\nis evaluated as\n\n p(s) = a[1] + (αs)*(a[2] + (αs)*(... + (αs)*(a[n-1] + a[n]*(αs))...)),\n\nwhere α=scaling. However, the function uses a call to graph_degopt, resulting in more degrees of freedom in crefs. See also graph_horner.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_ps","page":"Built-in graphs","title":"GraphMatFun.graph_ps","text":" (graph,crefs)=graph_ps(a; input=:A,\n                      B_base=:B, C_base=:C, P_base=:P)\n\nGenerates the graph for the Paterson–Stockmeyer procedure with monomial basis coefficieents. More precily, it corresponds to evaluation of the polynomial\n\np(s) = a[1] + a[2]*s + ... + a[n]*s^(n-1).\n\nReference:\n\nOn the number of nonscalar multiplications necessary to evaluate polynomials, M. Paterson, L. Stockmeyer, SIAM J. Comput., 2(1), 1973.\n\nThe code follows the description in:\n\nOptimality of the Paterson–Stockmeyer method for evaluating matrix polynomials and rational matrix functions, M. Fasi, Linear Algebra Appl., 574, 2019.\n\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_ps_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_ps_degopt","text":" (graph,crefs)=graph_ps_degopt(a; input=:A)\n\nGenerates the same polynomial as graph_ps, i.e., the graph for the Paterson–Stockmeyer procedure with monomial basis coefficieents. However, it does so by wrapping a call to graph_degopt, resulting in more degrees of freedom in crefs.\n\n\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_sastre_poly","page":"Built-in graphs","title":"GraphMatFun.graph_sastre_poly","text":"(graph,cref)=graph_sastre_poly(b)\n\nComputes the degree-8 polynomial\n\np(z)=b[1]+z*b[2]+z^2*b[3]+...+z^8*b[9]\n\naccording to Example 3.1 in the reference.\n\nReference:\n\nEfficient evaluation of matrix polynomials, J. Sastre. Linear Algebra and its Applications ,Volume 539, 2018, Pages 229-250, DOI: 10.1016/j.laa.2017.11.010\n\n\n\n\n\n","category":"function"},{"location":"generators/#Degree-optimal-polynomails","page":"Built-in graphs","title":"Degree-optimal polynomails","text":"","category":"section"},{"location":"generators/","page":"Built-in graphs","title":"Built-in graphs","text":"Degopt\ngraph_degopt\ngrow!\nscale!\nsquare!\nnormalize!\nget_degopt_coeffs\nget_degopt_crefs\nget_topo_order_degopt\ngraph_sastre_yks_degopt","category":"page"},{"location":"generators/#GraphMatFun.Degopt","page":"Built-in graphs","title":"GraphMatFun.Degopt","text":"degopt=Degopt(x,y)\ndegopt=Degopt(HA,HB,y)\ndegopt=Degopt(graph)\n\nstruct Degopt{T}\n    x::Vector{Tuple{Vector{T},Vector{T}}}\n    y::Vector{T}\nend\n\nCreates an object representing a degree optimal polynomial, i.e., the coefficients in an evaluation scheme which maximizes the degree for a fixed number of multiplications. The object represents the coefficients in\n\nA0=I\nA1=A\nA2=(x *A0+x *A1)(x *A0+x *A1)\nA4=(x *A0+x *A1+x*A2)(x *A0+x *A1+x *A2)\nA8=(x *A0+x *A1+x*A2)(x *A0+x *A1+x *A2)\n ..\n\nand\n\nOut=y*A0+y*A1+y*A4+y*A8+y*B4...\n\nThe x-values are given in the argument x, which is a Vector{Tuple{Vector{T},Vector{T}}}, containing the elements of each sum. The y-vector contains the elements to form the output. In the constructor with HA, HB and y the elements of x are stored as matrices.\n\nThe coefficients in graphs generated by graph_degopt can be recovered by using Degopt(graph).\n\n\n\n\n\n","category":"type"},{"location":"generators/#GraphMatFun.graph_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_degopt","text":"(graph,crefs)=graph_degopt(k;T=ComplexF64,input=:A)\n(graph,crefs)=graph_degopt(x,z;input=:A)\n(graph,crefs)=graph_degopt(d::Degopt;input=:A)\n\nCorresponds to the (for a fixed numer of multiplications) degree-optimal polynomial\n\nB1=A\nB2=(x *I+x *A)(x *I+x *A)\nB3=(x *I+x *A+x*B2)(x *I+x *A+x *B2)\n ..\n\nand\n\nOut=z*I+z*A1+z*B2+z*B3+z*B4...\n\nThe x-values are given in the argument x, which is a Vector{Tuple{Vector,Vector}}, containing the elements of each sum. The z-vector contains the elements to form the output, and input determines the name of the matrix A above. If the parameter k is supplied instead of the coefficients, all coeffs will be set to one.\n\nReference: The general recursion is mentioned in equation (9) in this paper:\n\nComputing the matrix exponential with an optimized Taylor polynomial approximation, P. Bader, S. Blanes, and F. Casas, Mathematics, 7(12), 2019.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.grow!","page":"Built-in graphs","title":"GraphMatFun.grow!","text":"grow!(degopt::Degopt)\n\nIncreases the Degopt by one multiplication without modifying the function values.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.scale!","page":"Built-in graphs","title":"GraphMatFun.scale!","text":"scale!(degopt::Degopt,α)\n\nEffectively change a Degopt such that the input is scaled by α. If p is the original function, p(α x) will be the new function.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.square!","page":"Built-in graphs","title":"GraphMatFun.square!","text":"square!(degopt::Degopt)\n\nEffectively square a Degopt in the sense that the output is square. If p is the original function, p(x)^2 will be the new function.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.get_degopt_coeffs","page":"Built-in graphs","title":"GraphMatFun.get_degopt_coeffs","text":"get_degopt_coeffs(degopt) -> (HA,HB,y)\nget_degopt_coeffs(graph) -> (HA,HB,y)\n\nReturns the coefficients of the degree-optimal polynomial using two matrices and one vectors as described in Degopt.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.get_degopt_crefs","page":"Built-in graphs","title":"GraphMatFun.get_degopt_crefs","text":"(x,z)=get_degopt_crefs(k)\n(x,z)=get_degopt_crefs(graph)\n\nRetruns crefs related to graph_degopt. Specifically x is a Vector{Tuple{Vector{Tuple{Symbol,Int}},Vector{Tuple{Symbol,Int}}}} such that x[2][1] corresponds to the coefficients of the left hand side of the multiplication\n\nB2=(α_2_1 *I + α_2_2 *A)(β_2_1 *I + β_2_2 *A)\n\ni.e., the crefs corresponding to [α_2_1, α_2_2]. See graph_degopt. Hence, get_coeffs(graph,x[2][1]) returns the corresponding numerical values of the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.get_topo_order_degopt","page":"Built-in graphs","title":"GraphMatFun.get_topo_order_degopt","text":"order=get_topo_order_degopt(k)\n\nA special implementation of get_topo_order for degree optimal polynomials generated with graph_degopt. The natural order of computation is to compute row by row. See also get_degopt_crefs.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_sastre_yks_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_sastre_yks_degopt","text":"(graph,cref)=graph_sastre_yks_degopt(k,s,c)\n\nTransforms the polynomial evaluation format given by equations (62)-(65) in the reference to degop-format. The graph is a representation of y_{k s}. Input c is a grouping of the coefficients as given by the representation (62)-(65). c is a Vector{Vector{Vector}} of length k+1, representing\n\n[\n[c_i^{(0,1)}, c_i^{(0,2)}]\n[c_i^{(1,1)}, c_i^{(1,2)}, c_i^{(1,3)}, c_i^{(1,4)}, c_i^{(1,5)}, c_i^{(1,6)}]\n...\n[c_i^{(k,1)}, c_i^{(k,2)}, c_i^{(k,3)}, c_i^{(k,4)}, c_i^{(k,5)}, c_i^{(k,6)}]\n]\n\nHence, c[1] contains two vectors, the first of length s-1 and the second of length s. (Note: In the first vector the constant for I is set to zero) and c[2] up to c[k+1] conatins six vectors: Even-numbered vectors have length s+1 Odd-numbered vectors have length j-1, where j is the intex in c, e.g., c[2][1] has one element and c[3][5] have two. For example, equations (57)-(59) are implemented as:\n\nc = [\n[[c15, c16], [0.0, 0, 0]], # (57)\n[[1.0], [0, c13, c14], [1.0], [c11, 0, c12], [c10], [0.0, 0, 0]], # (58)\n[[0.0, 1], [0, c8, c9], [c7, 1], [0, c6, 0], [c4, c5], [c1, c2, c3]], # (59)\n]\n\nReference:\n\nEfficient evaluation of matrix polynomials, J. Sastre. Linear Algebra and its Applications ,Volume 539, 2018, Pages 229-250, DOI: 10.1016/j.laa.2017.11.010\n\n\n\n\n\n","category":"function"},{"location":"generators/#Matrix-exponential","page":"Built-in graphs","title":"Matrix exponential","text":"","category":"section"},{"location":"generators/","page":"Built-in graphs","title":"Built-in graphs","text":"graph_exp_native_jl\ngraph_exp_native_jl_degopt\ngraph_sastre_exp\ngraph_sid_exp\ngraph_bbc_exp\ngraph_bbcs_cheb_exp","category":"page"},{"location":"generators/#GraphMatFun.graph_exp_native_jl","page":"Built-in graphs","title":"GraphMatFun.graph_exp_native_jl","text":" (graph,crefs)=graph_exp_native_jl(A; input=:A)\n\nCreates a graph for the native scaling-and-squaring for the matrix exponential, as implemented in Julia. The matrix A is taken as input to determine the length of the Padé approximant and the number of squares applied, as well as determining the type of the coefficients. The kwarg input determines the name of the matrix, in the graph.\n\nReferences:\n\nN. J. Higham. Functions of Matrices. SIAM publications, Philadelphia, PA, 2008.\nN. J. Higham. The Scaling and Squaring Method for the Matrix Exponential Revisited. SIAM J. Matrix Anal. Appl., 2005 26:4, 1179-1193\nJulia's matrix exponential, at the time of conversion.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_exp_native_jl_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_exp_native_jl_degopt","text":" (graph,crefs)=graph_exp_native_jl_degopt(A; input=:A)\n\nSame as graph_exp_native_jl but with calls to graph_degopt for contruction of numerator and denominator polynomials.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_sastre_exp","page":"Built-in graphs","title":"GraphMatFun.graph_sastre_exp","text":"(graph,cref)=graph_sastre_exp(k,method=:auto)\n\nComputes a polynomial evaluation approximating the exponential using k matrix multiplications following a method given in the reference. The schemes are embedded into degop-format, see graph_degopt.\n\nMethods are:\n\n:ps_degopt, Paterson–Stockmeyer method embedded into degopt-format.\n:y1s, given by equations (34)-(35)\n:z1ps, given by equations (34)-(35) and (52)\n:h2m, given by equations (34)-(35) and (69)\n\nNot all combinations of k and method are implemented. Available ones are:\n\nk<3, method=:ps_degopt\nk=3, method=:y1s, as per Table 4 in the reference\nk=4, method=:y1s\nk=6, method=:h2m, as per Table 11 in the reference\nk=8, method=:z1ps, as per Table 7 in the reference\n\nThe default option method=:auto will choose method according to the value of k, as prescribed above.\n\nReference:\n\nEfficient evaluation of matrix polynomials, J. Sastre. Linear Algebra and its Applications ,Volume 539, 2018, Pages 229-250, DOI: 10.1016/j.laa.2017.11.010\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_sid_exp","page":"Built-in graphs","title":"GraphMatFun.graph_sid_exp","text":"(graph,cref)=graph_sid_exp(k;T=Float64)\n\nComputes a polynomial evaluation approximating the exponential using k matrix multiplications following the procedure in the reference. The coefficients are directly copied from the paper.\n\nThe evaluation is embedded in the degopt-format, see graph_degopt, using the function graph_sastre_yks_degopt. Moreover, for k<=3 it uses the Paterson–Stockmeyer method.\n\nReference:\n\nBoosting the computation of the matrix exponential, J. Sastre, J. Ibáñez, E. Defez, Appl. Math. Computation, 340, 2019, 206-220.\n\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_bbc_exp","page":"Built-in graphs","title":"GraphMatFun.graph_bbc_exp","text":"(graph,cref)=graph_bbc_exp(k;T=Float64)\n\nComputes a polynomial evaluation approximating the exponential using k matrix multiplications following the procedure in the reference. The coefficients are directly copied from the paper.\n\nThe evaluation is embedded in the degopt-format, see graph_degopt, and for k<3, the evaluation is using the Paterson–Stockmeyer method.\n\nReference:\n\nComputing the matrix exponential with an optimized Taylor polynomial approximation, P. Bader, S. Blanes, and F. Casas, Mathematics, 7(12), 2019.\n\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_bbcs_cheb_exp","page":"Built-in graphs","title":"GraphMatFun.graph_bbcs_cheb_exp","text":"(graph,cref)=graph_bbcs_cheb_exp(k;T=Complex{BigFloat})\n\nComputes a polynomial evaluation approximating the exponential for skew-Hermitian matrices using k matrix multiplications following the procedure in the reference.\n\nFor k > 5 it resorts to scaling-and-squaring of the k = 5 graph. The graph is in the degopt format, see graph_degopt.\n\nReference:\n\nAn efficient algorithm to compute the exponential of skew-Hermitian matrices for the time integration of the Schrödinger equation, P. Bader, S. Blanes, F. Casas, M. Seydaoglu, arXiv:2103.10132\n\n\n\n\n\n\n","category":"function"},{"location":"generators/#Other-matrix-functions","page":"Built-in graphs","title":"Other matrix functions","text":"","category":"section"},{"location":"generators/","page":"Built-in graphs","title":"Built-in graphs","text":"graph_rational\ngraph_denman_beavers\ngraph_newton_schulz\ngraph_newton_schulz_degopt","category":"page"},{"location":"generators/#GraphMatFun.graph_rational","page":"Built-in graphs","title":"GraphMatFun.graph_rational","text":" (graph, cref) = graph_rational(den_coeffs, num_coeffs, poly_gen=graph_ps)\n (graph, cref) = graph_rational(den_graph, den_graph; den_cref=Vector{Tuple{Symbol,Int}}(), num_cref=Vector{Tuple{Symbol,Int}}())\n\nGenerates the graph for the rational approximation\n\nr(A)=q(A)^{-1}p(A)\n\nwhere p(A) and q(A) are polynomials defined by the coeficients den_coeffs and num_coeffs, and generated by the function poly_gen, which is called as (graph,cref)=polygen(coeffs), see, e.g., `graphmonomialandgraph_ps`.\n\nThe alternative call-signature involves the graphs for p and q directly, as den_graph and num_graph. The corresponding den_cref and num_cref can also be passed to be modified accodringly, otherwise the return value cref is empty for this call.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_denman_beavers","page":"Built-in graphs","title":"GraphMatFun.graph_denman_beavers","text":"    (graph,cref)=graph_denman_beavers(k;T=ComplexF64,cref_mode=0)\n\nCreates the graph corresponding to the Denman-Beavers iteration for the matrix square root, using k iterations. The kwarg cref_mode specifies if references to all X and Y (cref_mode=0) should be stored or just Y (cref_mode=-1) or just X (cref_mode=1).\n\nReference:\n\nThe matrix sign function and computations in systems, E. Denman,  A. Beavers, Applied Mathematics and Computation, 2(1), 1976, DOI: 10.1016/0096-3003(76)90020-5\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_newton_schulz","page":"Built-in graphs","title":"GraphMatFun.graph_newton_schulz","text":" (graph,crefs)=graph_newton_schulz(k, T=ComplexF64; input=:A, B=:B, C=:C, V=:V)\n\nDoes k iterations of the Newton–Schulz iteration for approximating the inverse of a matrix A (name given by input), i.e., the recursion\n\nV_k+1 = V_k*(2*I - A*V_k),\n\nwith V_0=A. The recursion is implemented using the graph-operations\n\nZ_i=A*V_i\nQ_i=2*I-Z_i\nV_{i+1}=V_i*Q_i,\n\nand the kwargs  Z, Q, and V determines the naming of the corresponding intermediate steps.\n\nReferences:\n\nGünther Schulz. Iterative Berechnung der reziproken Matrix. Z. Angew. Math. Mech., 13:57–59, 1933. DOI: 10.1002/zamm.19330130111\nN. J. Higham. Functions of Matrices. SIAM publications, Philadelphia, PA, 2008.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_newton_schulz_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_newton_schulz_degopt","text":" (graph,crefs)=graph_newton_schulz_degopt(k, T=ComplexF64; input=:A)\n\nDoes k iterations of the Newton–Schulz iteration for approximating the inverse, using the recursion\n\nZ_i=A*V_i\nV_{i+1}=V_i*(2*I-Z_i).\n\nThe function makes a call to graph_degopt, resulting in more degrees of freedom in crefs. See also graph_newton_schulz.\n\n\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphMatFun","category":"page"},{"location":"#GraphMatFun.jl","page":"Home","title":"GraphMatFun.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphMatFun.jl is a Julia package for working with computational graphs representing functions of matrices.","category":"page"},{"location":"#Installing","page":"Home","title":"Installing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The latest release of the package can be installed as ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\n(v1.6) pkg> add GraphMatFun","category":"page"},{"location":"","page":"Home","title":"Home","text":"When installed, the package can be loaded into the current session by writing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using GraphMatFun","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"optim/#Graph-optimization","page":"Graph optimization","title":"Graph optimization","text":"","category":"section"},{"location":"optim/","page":"Graph optimization","title":"Graph optimization","text":"opt_gauss_newton!\neval_jac\nopt_linear_fit!\nsolve_linlsqr!\nadjust_for_errtype!","category":"page"},{"location":"optim/#GraphMatFun.opt_gauss_newton!","page":"Graph optimization","title":"GraphMatFun.opt_gauss_newton!","text":"(iter,resnorm)=opt_gauss_newton!(graph, objfun, discr; maxit = 100, logger = 0,\n                                 errtype = :abserr, stoptol = 1e-6,\n                                 input=:A, cref = get_all_cref(graph),\n                                 γ0 = 1.0, linlsqr = :backslash, droptol = 0)\n\nApplies the Gauss–Newton algorithm to solve the nonlinear least squares problem: Fit the output of the graph to the values of objfun, in the points discr.\n\nThe variable graph is modified during the iterations. The function returns the iteration iter where it terminated, and the corresponding residual norm resnorm.\n\nThe kwargs are as follows: maxit determines the maximum number of iterations. If logger has a value >0, then the intermediate results are printed. errtype determines the error type measured, see adjust_for_errtype!. stoptol is the corresponding stopping tolerence. cref is a Vector{Tuple{Symbol,Int}} that determines which coefficients of graph that are considered free variables and optimized. input is the label corresponding to the input node of the graph. The stepsize can be scaled with γ0. linlsqr and droptol determines how the inner linear least squares problem is solved; see solve_linlsqr!.\n\n\n\n\n\n\n\n","category":"function"},{"location":"optim/#GraphMatFun.eval_jac","page":"Graph optimization","title":"GraphMatFun.eval_jac","text":"J=eval_jac(graph, x, cref; vals=nothing,\n           input=:A, output=size(graph.outputs,1))\n\nComputes Jacobian J = dZ(x_i)/dc, with respect to the coefficients given in the vector cref, and points in x. See eval_graph for  description of vals and output.\n\n\n\n\n\n","category":"function"},{"location":"optim/#GraphMatFun.opt_linear_fit!","page":"Graph optimization","title":"GraphMatFun.opt_linear_fit!","text":"opt_linear_fit!(graph, objfun, discr, linear_cref;\n                input = :A,\n                errtype = :abserr,\n                linlsqr = :backslash,\n                droptol = 0)\n\nLinear fitting of a graph of the form\n\nc_1 g_1(x) + c_2 g_2(x) + … + c_n g_n(x)\n\nto the values of objfun, in the points discr. Reference to the coefficients c_1,…,c_n should be given linear_cref.\n\nThe variable graph is modified during the iterations and the function has no return value.\n\nSee opt_gauss_newton! for a description the kwarg errtype and input, and solve_linlsqr! for the kwargs linlsqr anddroptol`.\n\n\n\n\n\n\n\n","category":"function"},{"location":"optim/#GraphMatFun.solve_linlsqr!","page":"Graph optimization","title":"GraphMatFun.solve_linlsqr!","text":"d = solve_linlsqr!(A, b, linlsqr, droptol)\n\nSolves the linear least squares problem\n\nAd=b.\n\nThe argument linlsqr determines how the linear least squares problem is solved. It can be :backslash, :real_backslash, :nrmeq, :real_nrmeq, :svd, or :real_svd. For the latter two options singular values below droptol are disregarded. The :real_X options optimizes d in the space of real vectors. The input matrix A is sometimes overwritten.\n\n\n\n\n\n","category":"function"},{"location":"optim/#GraphMatFun.adjust_for_errtype!","page":"Graph optimization","title":"GraphMatFun.adjust_for_errtype!","text":"adjust_for_errtype!(A, b, objfun_vals, errtype)\n\nAdjusts the matrix A and vector b to errtype. A is a matrix, e.g., the Jacobian or system matrix in a least squares problem. b is a vector, e.g., the residuals or the right-hand side in a lieast squares problem. objfun_vals is a vector of objective function values, and errtype can be :abserr or :relerr, i.e., absolute error or relative error.\n\n\n\n\n\n","category":"function"}]
}
