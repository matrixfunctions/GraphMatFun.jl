var documenterSearchIndex = {"docs":
[{"location":"docidx/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"docidx/","page":"Index","title":"Index","text":"","category":"page"},{"location":"graph/#Graphs-and-their-manipulation","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"","category":"section"},{"location":"graph/#The-computational-graph-–-Compgraph","page":"Graphs and their manipulation","title":"The computational graph – Compgraph","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"The computational graph is represented by a struct Compgraph{T}, where T is the type of the coefficients. Each node in the graph is represented by a Symbol, and these node-IDs need to be unique for every node.","category":"page"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"Compgraph","category":"page"},{"location":"graph/#GraphMatFun.Compgraph","page":"Graphs and their manipulation","title":"GraphMatFun.Compgraph","text":"graph=Compgraph(T::Type=ComplexF64)\n\nCreates an empty computation graph of with coefficients of type T.\n\n\n\n\n\ngraph=Compgraph(T,orggraph::Compgraph)\n\nConverts a graph such that the coefficients become type T. Note that T can be a Number but can be other objects with defined operations, or just Any.\n\n\n\n\n\n","category":"type"},{"location":"graph/#Manipulating-graph-topology","page":"Graphs and their manipulation","title":"Manipulating graph topology","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"In general a graph is composed of linear combinations C = alpha A + beta B (add_lincomb!), multiplication C = AB (add_mult!), and left inverse C = A^-1B  (add_ldiv!).","category":"page"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"add_lincomb!\nadd_mult!\nadd_ldiv!","category":"page"},{"location":"graph/#GraphMatFun.add_lincomb!","page":"Graphs and their manipulation","title":"GraphMatFun.add_lincomb!","text":"add_lincomb!(graph,node,α1,p1,α2,p2)\n\nThe operation α1*p1+α2*p2 is added to the graph. The result is stored in node node.\n\n\n\n\n\nadd_lincomb!(graph,node,coeffs,nodes)\n\nAdds a linear combination of the nodes (Vector or Tuple) multiplied with coeffs (Vector or Tuple). Returns cref vector.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.add_mult!","page":"Graphs and their manipulation","title":"GraphMatFun.add_mult!","text":"add_mult!(graph,node,p1,p2)\n\nAdds a multiplication of node p1 and p2 to the graph. The result is stored in node node.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.add_ldiv!","page":"Graphs and their manipulation","title":"GraphMatFun.add_ldiv!","text":"add_ldiv!(graph,node,p1,p2)\n\nThe operation inv(p1)*p2 is added to the graph. The result is stored in node node.\n\n\n\n\n\n","category":"function"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"The graph can have multiple outputs and the behavior controlled.","category":"page"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"add_output!\ndel_output!\nclear_outputs!","category":"page"},{"location":"graph/#GraphMatFun.add_output!","page":"Graphs and their manipulation","title":"GraphMatFun.add_output!","text":"add_output!(graph,node)\n\nAdds node to the bottom of the list of outputs of the graph.\n\nSee also eval_graph, eval_jac, and eval_runerr.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.del_output!","page":"Graphs and their manipulation","title":"GraphMatFun.del_output!","text":"del_output!(graph,node)\n\nRemoves the output node from the list of output nodes of the graph. This function does not remove the node from the graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.clear_outputs!","page":"Graphs and their manipulation","title":"GraphMatFun.clear_outputs!","text":"clear_outputs!(graph)\n\nClears the list of output nodes of the graph. This function does not remove the node nodes from the graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"It is also possible to merge two graphs, and to rename and delete nodes.","category":"page"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"merge_graphs\nrename_node!\ndel_node!","category":"page"},{"location":"graph/#GraphMatFun.merge_graphs","page":"Graphs and their manipulation","title":"GraphMatFun.merge_graphs","text":"graph=merge_graphs(\ngraph1,\ngraph2;\nprefix1 = \"\",\nprefix2 = \"G2\",\nskip_basic1 = true,\nskip_basic2 = true,\ncref1 = Vector(),\ncref2 = Vector(),\ninput1 = :A,\ninput2 = :A,\n\n)\n\nTakes all the nodes and edges in graph1 and graph2 and generates a new graph. The node names are in graph1 are changed by adding a prefix prefix1 and graph2 correspondingly. The nodes :I and :A are unchanged if skip_basicX=true. All coefficient references crefX are modified accordingly.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.rename_node!","page":"Graphs and their manipulation","title":"GraphMatFun.rename_node!","text":"rename_node!(graph,src,dest,cref=Vector())\n\nThis changes the name of the node src to dest and updates all references to the node, including coefficient references in cref and graph.outputs.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.del_node!","page":"Graphs and their manipulation","title":"GraphMatFun.del_node!","text":"del_node!(graph,node)\n\nDeletes node from the graph, and all data associated with it, except for graph.outputs.\n\nSee del_output!.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Evaluating-the-graph","page":"Graphs and their manipulation","title":"Evaluating the graph","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"eval_graph\nget_topo_order","category":"page"},{"location":"graph/#GraphMatFun.eval_graph","page":"Graphs and their manipulation","title":"GraphMatFun.eval_graph","text":"result=eval_graph(\n    graph,\n    x;\n    vals = nothing,\n    input = :A,\n    output = size(graph.outputs, 1),\n    comporder = nothing,\n)\n\nEvaluates a graph in the value x which is typically a scalar value or a matrix. If x is a Vector, the values will be evaluated elementwise.\n\nThe comporder is a Vector of nodes specifying in which order the graph should be computed. By default get_topo_order is used.\n\nThe output is an Int specifying which node should be considered as output. The output node is graph.outputs[output].\n\nThe vals is used to inspect contents other than the output inside the graph. Typically vals is a Dict. It will be modified to contain the computed nodes of the graph. If we wish to inspect node X3, we can initiate an empty dict as input:\n\njulia > vals = Dict{Symbol,Any}();\njulia > eval_graph(graph, A, vals = vals);\njulia > vals[:X3]\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.get_topo_order","page":"Graphs and their manipulation","title":"GraphMatFun.get_topo_order","text":"(order,can_be_deallocated,max_nodes)=get_topo_order(\n    graph;\n    priohelp = Dict{Symbol,Float64}(),\n    free_mem_bonus = 1000,\n    will_not_dealloc = [:I],\n    input = :A,\n)\n\nComputes a topological sort of graph, that is, an ordering of the nodes following which the function the graph represents can be evaluated. The priohelp kwarg can be used to obtain a different topological ordering by changing the node priority. The code assumes that the nodes :I and input do not need to be computed.\n\nThe code uses a heuristic to minimize pathwidth. It is based on a point system. You can influence the computation order by providing a priohelp. If you want node :B4 to be computed earlier, you can set priohelp[:B4]=-5000.0. The free_mem_bonus is used in the heuristic to prioritize the computation of nodes which release other nodes. The vector will_not_deallocate influences the order specifying nodes that will not be deallocated and therefore gets no free_mem_bonus.\n\nThe return value order is a Vector of Symbols, and can_be_deallocated is a Vector{Vector{Symbol}} where the element i specifies the Symbols that are unused after step i in the ordering. The max_nodes is the pathwidth.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Nodes-and-coefficients","page":"Graphs and their manipulation","title":"Nodes and coefficients","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"get_sorted_keys\nget_all_cref\nget_coeffs\nset_coeffs!","category":"page"},{"location":"graph/#GraphMatFun.get_sorted_keys","page":"Graphs and their manipulation","title":"GraphMatFun.get_sorted_keys","text":"v=get_sorted_keys(graph)\n\nReturns a list of all nodes, sorted.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.get_all_cref","page":"Graphs and their manipulation","title":"GraphMatFun.get_all_cref","text":"v=get_all_cref(graph)\n\nReturns a list with references to all coefficients in the graph. The list is sorted.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.get_coeffs","page":"Graphs and their manipulation","title":"GraphMatFun.get_coeffs","text":"x=get_coeffs(graph, cref=get_all_cref(graph))\n\nGets the coefficient values for the coefficients specified in cref::Vector.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.set_coeffs!","page":"Graphs and their manipulation","title":"GraphMatFun.set_coeffs!","text":"set_coeffs!(graph, x, cref=get_all_cref(graph))\n\nSets the coefficient values in the coefficients specified in cref::Vector to the values in the vector in x::Vector.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Errors-and-error-bounds","page":"Graphs and their manipulation","title":"Errors and error bounds","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"compute_bwd_theta\ncompute_fwd_theta\ncompute_bnd_rel_bwd_err\neval_runerr","category":"page"},{"location":"graph/#GraphMatFun.compute_bwd_theta","page":"Graphs and their manipulation","title":"GraphMatFun.compute_bwd_theta","text":"(e_bwd,theta)=compute_bwd_theta(;\n    bnd_rel_err = compute_bnd_rel_bwd_err(:exp, graph),\n    tolerance = eps(coefftype) / 2,\n    theta_init = big\"0.2\",\n    use_log = false,\n)\n\n(e_bwd,theta)=compute_bwd_theta(\n    graph::Compgraph{T};\n    coefftype = T,\n    numterms = 100,\n    numdigits = 100,\n    tolerance = eps(coefftype) / 2,\n    theta_init = big\"0.2\",\n    use_log = false,\n)\n\nCompute bound on relative backward error with corresponding theta.\n\nThe first output e_bwd is a function that returns a bound on the relative backward error of the polynomial underlying the computational graph graph, seen as an approximant to the exponential. For the underlying polynomial p, the function returns a bound on |δ| where δ is such that exp(z+δ) = p(z). This function is computed using compute_bnd_rel_bwd_err(:graph).\n\nThe second output θ is the largest positive real number such that e_bwd(θ)  tolerance, where tolerance is by default the unit roundoff of the data type coefftype, which in turn defaults to the type of the coefficients of graph.\n\nThe value of theta is estimated by approximately solving the equation e_bwd(z) = tolerance, using the built-in function fzero with starting value set to theta_init. By default this root-finding procedure uses high-precision arithmetic.\n\nIf the kwarg use_log is set to true, then the value of theta is computed by approximating a solution to the equation log(e_bwd(z)) = log(tolerance) instead.\n\nThe alternative form accepts a function that returns a bound on the relative backward error. By default, the function is constructed with compute_bnd_rel_bwd_err(:exp, ...) and the default values for the kwargs in the first form.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.compute_fwd_theta","page":"Graphs and their manipulation","title":"GraphMatFun.compute_fwd_theta","text":"(e_fwd,theta)=compute_fwd_theta(\n    graph::Compgraph{T},\n    f;\n    coefftype = T,\n    tolerance = eps(coefftype) / 2,\n    theta_init = big\"0.1\",\n)\n\nReturn relative forward error and corresponding theta for approximation to f.\n\nThe first output e_fwd is the function that computes the relative forward errore_fwd(z)=f(z) - p(z)  z, where p is the polynomial underlying the computational graph graph. This is meaningful only if p approximates f in some sense.\n\nThe second output θ is the largest positive real number such that e_fwd(θ)  tolerance, where tolerance is by default the unit roundoff of the data type coefftype, which in turn defaults to the type of the coefficients of graph.\n\nThe value of θ is approximated by using the built-in function fzero with starting value set to theta_init. By default, this root-finding procedure uses high-precision arithmetic.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.compute_bnd_rel_bwd_err","page":"Graphs and their manipulation","title":"GraphMatFun.compute_bnd_rel_bwd_err","text":"e_bwd=compute_bnd_rel_bwd_err(\n    f,\n    graph::Compgraph{T};\n    coefftype = T,\n    numterms = 100,\n    numdigits = 100,\n)\n\nCompute a bound on the relative backward error of the function f.\n\nThe returned function e_bwd is a bound on the relative backward error of the polynomial underlying the computational graph graph, seen as an approximant to f. For the underlying polynomial p, the function returns a bound on |δ| where δ is such that f(z+δ) = p(z).\n\nThe first argument f is a symbol. Currently supported values include:\n\n:exp The bound is computed by means of the identity δ = log((exp(-z) p(z)-1)+1). The code computes the series expansion of the right-hand side of the equation, truncates it to the first numterms coefficients, bounds each coefficient of the ensuing polynomial with its absolute value. The computation uses numdigits digits of precision.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.eval_runerr","page":"Graphs and their manipulation","title":"GraphMatFun.eval_runerr","text":"err=eval_runerr(\n    graph,\n    x;\n    vals = nothing,\n    relerrs = nothing,\n    input = :A,\n    output = size(graph.outputs, 1),\n    mode = :bounds, # Can be :bounds, :rand, :estimate\n    add_relerr = eps(),\n)\n\nProvides the running error of the graph evaluated in x. See eval_graph for meaning of vals and output. The kwarg relerrs is an anologous variable for the running error estimates in each node. The kwarg mode can be :bounds, :rand, :estimate, specifying if the code should make estimates or bounds, or random error within the bound.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Reading-and-writing-graphs-to-file","page":"Graphs and their manipulation","title":"Reading and writing graphs to file","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"export_compgraph\nimport_compgraph","category":"page"},{"location":"graph/#GraphMatFun.export_compgraph","page":"Graphs and their manipulation","title":"GraphMatFun.export_compgraph","text":"function export_compgraph(\n        graph,\n    fname;\n    order = get_topo_order(graph)[1],\n    fun = \"\",\n    dom = \"\",\n    err = \"\",\n    genby = \"\",\n    descr = \"\",\n    user = splitdir(homedir())[end],\n)\n\nExports the graph to the file fname using the computation graph format (cgr). These kwargs are strings or values that are stored as comments in the file\n\ndescr of the graph\nfun function it approximates\ndom domain it approximates\nerr error in this domain\ngenby script that generated this file\nuser a username that created the file\n\nThese kwarg influence how the graph is stored:\n\norder specifies an order the graph nodes are stored\n\nCGR format:\n\nEvery line corresponds to a node / operation. The syntax is matlab compatible, although gen_code produces faster matlab code.\n\nSee also export_compgraph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.import_compgraph","page":"Graphs and their manipulation","title":"GraphMatFun.import_compgraph","text":"graph=import_compgraph(fname)\n\nReads a graph stored in the computation graph format (cgr) in the file fname.\n\nSee also import_compgraph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Helpers-and-convenience-functions","page":"Graphs and their manipulation","title":"Helpers and convenience functions","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"get_polynomial\nget_polynomial_coefficients\neltype\nbig\ncomplex","category":"page"},{"location":"graph/#GraphMatFun.get_polynomial","page":"Graphs and their manipulation","title":"GraphMatFun.get_polynomial","text":"p = get_polynomial(graph::Compgraph)\n\nReturn the polynomial underlying the computational graph. The graph is assumed to involve only linear combinations and multiplications.\n\np is polynomial of type Polynomial from the package Polynomials.jl.\n\nSee also get_polynomial_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.get_polynomial_coefficients","page":"Graphs and their manipulation","title":"GraphMatFun.get_polynomial_coefficients","text":"c = get_polynomial_coefficients(graph::Compgraph)\n\nReturn the coefficients of the polynomial underlying the computational graph. The graph is assumed to involve only linear combinations and multiplications.\n\nThe coefficients c is a vector containing the coefficients as expressed in the monomial basis and sorted from the leading coefficient to the constant term.\n\nSee also get_polynomial.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Base.eltype","page":"Graphs and their manipulation","title":"Base.eltype","text":"T=eltpye(graph::Compgraph{T})\n\nReturns the type T of a graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Base.big","page":"Graphs and their manipulation","title":"Base.big","text":"bgraph=big(graph::Compgraph{T})\n\nConverts the coefficients of graph to type big(T) and returns bgraph, which is of type Compgraph{big(T)}.\n\nSee also Compgraph(T,orggraph::Compgraph).\n\n\n\n\n\n","category":"function"},{"location":"graph/#Base.complex","page":"Graphs and their manipulation","title":"Base.complex","text":"cgraph=big(graph::Compgraph{T})\n\nConverts the coefficients of graph to type complex(T) and returns cgraph, which is of type Compgraph{complex(T)}.\n\nSee also Compgraph(T,orggraph::Compgraph).\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#Code-generation-and-efficiency","page":"Code generation and efficiency","title":"Code generation and efficiency","text":"","category":"section"},{"location":"code_gen/","page":"Code generation and efficiency","title":"Code generation and efficiency","text":"While the graph can be evaluated with eval_graph, the ideal way to utilize a good graph is to produce efficient code. Currently code generation to Julia, Matlab, and C is supported.","category":"page"},{"location":"code_gen/#Improving-graph-topology","page":"Code generation and efficiency","title":"Improving graph topology","text":"","category":"section"},{"location":"code_gen/","page":"Code generation and efficiency","title":"Code generation and efficiency","text":"The Compgraph is a general framework, and sometimes the topology can be improved. This is especially important before code generation.","category":"page"},{"location":"code_gen/","page":"Code generation and efficiency","title":"Code generation and efficiency","text":"compress_graph!\ncompress_graph_output_cleaning!\ncompress_graph_dangling!\ncompress_graph_redundant!\ncompress_graph_trivial!\ncompress_graph_zero_coeff!\ncompress_graph_passthrough!\nextract_sums\nhas_trivial_nodes\nhas_identity_lincomb","category":"page"},{"location":"code_gen/#GraphMatFun.compress_graph!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph!","text":"compress_graph!(graph,cref=[];verbose=false)\n\nSearches for nodes which can be removed or reorganized without changing the function it represents. Corresponding references in the cref-vector are removed.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.compress_graph_dangling!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph_dangling!","text":"compress_graph_dangling!(graph,cref=[];verbose=false)\n\nRemoves dangling nodes in the graph. If a node is not used anywhere and it is not in the output, it can safely be removed.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.compress_graph_redundant!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph_redundant!","text":"compress_graph_redundant!(\n    graph,\n    cref = [];\n    compress_lincomb = true,\n    verbose = false,\n)\n\nRemoves from the graph redundant nodes, that is, nodes that repeat a computation that is already present in the graph. Nodes corresponding to a linear combination are removed only if the coefficients are the same and compress_lincomb is set to true.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.compress_graph_trivial!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph_trivial!","text":"compress_graph_trivial!(graph,cref=[];verbose=false)\n\nRemoves from graph the following operations    I\\B -> B    IB -> B    BI -> B\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.compress_graph_zero_coeff!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph_zero_coeff!","text":"compress_graph_zero_coeff!(graph,cref=[];droptol=0;verbose=false)\n\nSearches for linear combinations with zero coeff and removes those. The cref list deletes references to zero coeffs and updates all other crefs.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.compress_graph_passthrough!","page":"Code generation and efficiency","title":"GraphMatFun.compress_graph_passthrough!","text":"compress_graph_passthrough!(graph,cref=[];verbose=false);\n\nIdentifies lincombs of length one with coeff equal to one. The node has no effect and is redirected appropriately.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.has_trivial_nodes","page":"Code generation and efficiency","title":"GraphMatFun.has_trivial_nodes","text":"has_trivial_node(graph) -> Bool\n\nChecks whether the graph has trivial nodes, that is, multiplications by the identity or linear systems whose coefficient is the identity matrix.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.has_identity_lincomb","page":"Code generation and efficiency","title":"GraphMatFun.has_identity_lincomb","text":"has_identity_lincomb(graph) -> Bool\n\nChecks whether the graph has a node which is a linear combination of identity matrices.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#Code-generation","page":"Code generation and efficiency","title":"Code generation","text":"","category":"section"},{"location":"code_gen/","page":"Code generation and efficiency","title":"Code generation and efficiency","text":"gen_code\nLangJulia\nLangMatlab\nLangC_MKL\nLangC_OpenBLAS","category":"page"},{"location":"code_gen/#GraphMatFun.gen_code","page":"Code generation and efficiency","title":"GraphMatFun.gen_code","text":"gen_code(\n    fname,\n    graph;\n    priohelp = Dict{Symbol,Float64}(),\n    lang = LangJulia(),\n    funname = \"dummy\",\n    precomputed_nodes = [:A],\n)\n\nGenerates the code for the graph in the language specified in lang and writes it into the file fname. The string funname is the function name. Topological order of the nodes is comptued using get_topo_order and priohelp can be used to influence the order. The nodes listed in precomputed_nodes are viewed as inputs, and code to compute these nodes are not computed.\n\nCurrently supported languages: LangC_MKL, LangC_OpenBLAS, LangJulia, LangMatlab.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.LangJulia","page":"Code generation and efficiency","title":"GraphMatFun.LangJulia","text":"LangJulia(overwrite_input=true,inline=true,alloc_function,only_overwrite=false)\n\nCode generation in julia language, with optional overwriting of input. The parameter alloc_function is a function of three parameters alloc_function(k) where k is the memory slot (default is alloc_function(k)=similar(A,T)). The only_overwrite specifies if f should be created if the overwrite funtion     f! contains the actual code.\n\n\n\n\n\n","category":"type"},{"location":"code_gen/#GraphMatFun.LangMatlab","page":"Code generation and efficiency","title":"GraphMatFun.LangMatlab","text":"LangMatlab()\n\nCode generation for the Matlab language.\n\n\n\n\n\n","category":"type"},{"location":"code_gen/#GraphMatFun.LangC_MKL","page":"Code generation and efficiency","title":"GraphMatFun.LangC_MKL","text":" LangC_MKL(gen_main::Bool)\n\nCode generation in C using the oneAPI MKL implementation of BLAS.\n\n\n\n\n\n","category":"type"},{"location":"code_gen/#GraphMatFun.LangC_OpenBLAS","page":"Code generation and efficiency","title":"GraphMatFun.LangC_OpenBLAS","text":" LangC_OpenBLAS(gen_main::Bool)\n\nCode generation in C using the OpenBLAS implementation of BLAS.\n\n\n\n\n\n","category":"type"},{"location":"generators/#Built-in-graphs","page":"Built-in graphs","title":"Built-in graphs","text":"","category":"section"},{"location":"generators/#Polynomials","page":"Built-in graphs","title":"Polynomials","text":"","category":"section"},{"location":"generators/","page":"Built-in graphs","title":"Built-in graphs","text":"Standard evaluation schemes such as monomial evaluation (graph_monomial), Horner evaluation (graph_horner) and Paterson–Stockmeyer (graph_ps) are available. There are also the degree-optimal polynomials (Degopt) described in the next section.","category":"page"},{"location":"generators/","page":"Built-in graphs","title":"Built-in graphs","text":"graph_monomial\ngraph_monomial_degopt\ngraph_horner\ngraph_horner_degopt\ngraph_ps\ngraph_ps_degopt\ngraph_sastre_poly","category":"page"},{"location":"generators/#GraphMatFun.graph_monomial","page":"Built-in graphs","title":"GraphMatFun.graph_monomial","text":" (graph,crefs)=graph_monomial(a; input=:A, polyname=:P)\n\nGenerates the graph for the polynomial using the monomial basis coefficients. More precisely, it corresponds to the evaluation of the polynomial\n\np(s) = a[1] + a[2]*s + ... + a[n]*s^(n-1),\n\nwhere s^k is naively evaluated as s^k=s*s^(k-1) for k=2,3,...,n-1. The kwarg polyname specifies the name of intermediate variables.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_monomial_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_monomial_degopt","text":" (graph,crefs)=graph_monomial_degopt(a; input=:A)\n\nGenerates the same polynomial as graph_monomial, in the monomial basis. However, it does so by wrapping a call to graph_degopt, resulting in more degrees of freedom in crefs.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_horner","page":"Built-in graphs","title":"GraphMatFun.graph_horner","text":" (graph,crefs)=graph_horner(a; input=:A, B=:B, C=:C, scaling=1.0)\n\nGenerates the graph for the polynomial using Horner's method. More precisely, it corresponds to the evaluation of the polynomial\n\np(s) = a[1] + a[2]*(αs) + ... + a[n-1]*(αs)^(n-2) + a[n]*(αs)^(n-1),\n\nas the recursion\n\nCj=s*B{j+1}\nBj=a[j]*I+α*Cj,\n\nwhere α=scaling.\n\nThe kwargs B and C specifies the base-names of these intermediate variables.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_horner_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_horner_degopt","text":" (graph,crefs)=graph_horner_degopt(a; scaling=1.0, input=:A)\n\nGenerates a polynomial using Horner's evaluation scheme. The polynomial\n\n p(s) = a[1] + a[2]*(αs) + ... + a[n-1]*(αs)^(n-2) + a[n]*(αs)^(n-1),\n\nis evaluated as\n\n p(s) = a[1] + (αs)*(a[2] + (αs)*(... + (αs)*(a[n-1] + a[n]*(αs))...)),\n\nwhere α=scaling. However, the function uses a call to graph_degopt, resulting in more degrees of freedom in crefs. See also graph_horner.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_ps","page":"Built-in graphs","title":"GraphMatFun.graph_ps","text":" (graph,crefs)=graph_ps(a; input=:A,\n                      B_base=:B, C_base=:C, P_base=:P)\n\nGenerates the graph for the Paterson–Stockmeyer procedure with monomial basis coefficieents. More precisely, it corresponds to evaluation of the polynomial\n\np(s) = a[1] + a[2]*s + ... + a[n]*s^(n-1).\n\nThe code follows the description in the second of the papers referenced below.\n\nReferences\n\nM. Paterson and L. Stockmeyer. \"On the number of nonscalar multiplications necessary to evaluate polynomials\". SIAM Journal on Scientific Computing, 2(1):60-66, 1973. DOI: 10.1137/0202007\nM. Fasi. \"Optimality of the Paterson–Stockmeyer method for evaluating matrix polynomials and rational matrix functions\". Linear Algebra and its Applications, 574, 2019. DOI: 10.1016/j.laa.2019.04.001\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_ps_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_ps_degopt","text":" (graph,crefs)=graph_ps_degopt(a; input=:A)\n\nGenerates the same polynomial as graph_ps, i.e., the graph for the Paterson–Stockmeyer procedure with monomial basis coefficieents. However, it does so by wrapping a call to graph_degopt, resulting in more degrees of freedom in crefs.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_sastre_poly","page":"Built-in graphs","title":"GraphMatFun.graph_sastre_poly","text":"(graph,cref)=graph_sastre_poly(b)\n\nComputes the degree-8 polynomial\n\np(z)=b[1]+z*b[2]+z^2*b[3]+...+z^8*b[9]\n\naccording to Example 3.1 in the reference.\n\nReference\n\nJ. Sastre. \"Efficient evaluation of matrix polynomials\". Linear Algebra and its Applications, 539:229-250, 2018. DOI: 10.1016/j.laa.2017.11.010\n\n\n\n\n\n","category":"function"},{"location":"generators/#Degree-optimal-polynomials","page":"Built-in graphs","title":"Degree-optimal polynomials","text":"","category":"section"},{"location":"generators/","page":"Built-in graphs","title":"Built-in graphs","text":"The degree-optimal polynomial is a multiplication-economic scheme for evaluating polynomials. It has the possibility to reach the highest attainable degree possible for a fixed number of multiplications, i.e., degree equal to 2^m with m multiplication. However, the set of degree-optimal polynomials does not span the whole set of polynomials of degree less than or equal to 2^m. Provided optimization techniques are therefore useful to achieve good approximations.","category":"page"},{"location":"generators/","page":"Built-in graphs","title":"Built-in graphs","text":"Degopt\ngraph_degopt\ngrow!\nscale!\nsquare!\nnormalize!\nget_degopt_coeffs\nget_degopt_crefs\nget_topo_order_degopt\ngraph_sastre_yks_degopt","category":"page"},{"location":"generators/#GraphMatFun.Degopt","page":"Built-in graphs","title":"GraphMatFun.Degopt","text":"degopt=Degopt(x,y)\ndegopt=Degopt(HA,HB,y)\ndegopt=Degopt(graph)\n\nstruct Degopt{T}\n    x::Vector{Tuple{Vector{T},Vector{T}}}\n    y::Vector{T}\nend\n\nCreates an object representing a degree-optimal polynomial, i.e., the coefficients in an evaluation scheme which maximizes the degree for a fixed number of multiplications. The object represents the coefficients in\n\nA0=I\nA1=A\nA2=(x *A0+x *A1)(x *A0+x *A1)\nA4=(x *A0+x *A1+x*A2)(x *A0+x *A1+x *A2)\nA8=(x *A0+x *A1+x*A2)(x *A0+x *A1+x *A2)\n ..\n\nand\n\nOut=y*A0+y*A1+y*A4+y*A8+y*B4...\n\nThe x-values are given in the argument x, which is a Vector{Tuple{Vector{T},Vector{T}}}, containing the elements of each sum. The y-vector contains the elements to form the output. In the constructor with HA, HB and y the elements of x are stored as matrices.\n\nThe coefficients in graphs generated by graph_degopt can be recovered by using Degopt(graph).\n\n\n\n\n\n","category":"type"},{"location":"generators/#GraphMatFun.graph_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_degopt","text":"(graph,crefs)=graph_degopt(k;T=ComplexF64,input=:A)\n(graph,crefs)=graph_degopt(x,z;input=:A)\n(graph,crefs)=graph_degopt(d::Degopt;input=:A)\n\nCorresponds to the (for a fixed number of multiplications) degree-optimal polynomial\n\nB1=A\nB2=(x *I+x *A)(x *I+x *A)\nB3=(x *I+x *A+x*B2)(x *I+x *A+x *B2)\n ..\n\nand\n\nOut=z*I+z*A1+z*B2+z*B3+z*B4...\n\nThe x-values are given in the argument x, which is a Vector{Tuple{Vector,Vector}}, containing the elements of each sum. The z-vector contains the elements to form the output, and input determines the name of the matrix A above. If the parameter k is supplied instead of the coefficients, all coeffs will be set to one. The general recursion is given in (9) in the paper referenced below.\n\nReference\n\nP. Bader, S. Blanes, and F. Casas, \"Computing the matrix exponential with an optimized Taylor polynomial approximation\", Mathematics, 7(12), 2019. DOI: 10.3390/math7121174\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.grow!","page":"Built-in graphs","title":"GraphMatFun.grow!","text":"grow!(degopt::Degopt)\n\nIncreases the Degopt by one multiplication without modifying the function values.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.scale!","page":"Built-in graphs","title":"GraphMatFun.scale!","text":"scale!(degopt::Degopt,α)\n\nEffectively change a Degopt such that the input is scaled by α. If p is the original function, p(α x) will be the new function.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.square!","page":"Built-in graphs","title":"GraphMatFun.square!","text":"square!(degopt::Degopt)\n\nEffectively square a Degopt in the sense that the output is square. If p is the original function, p(x)^2 will be the new function.\n\n\n\n\n\n","category":"function"},{"location":"generators/#LinearAlgebra.normalize!","page":"Built-in graphs","title":"LinearAlgebra.normalize!","text":"normalize!(degopt::Degopt,tp=:row1) -> degopt\n\nNormalizes the Degopt coefficients, in the way specified by tp. If the tp==:row1 the degopt will be transformed to an equivalent Degopt with first row equal to (0 1) (0 1).  If tp==:col1 the first column in the Ha and Hb matrices will be transformed to zero.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.get_degopt_coeffs","page":"Built-in graphs","title":"GraphMatFun.get_degopt_coeffs","text":"get_degopt_coeffs(degopt) -> (HA,HB,y)\nget_degopt_coeffs(graph) -> (HA,HB,y)\n\nReturns the coefficients of the degree-optimal polynomial using two matrices and one vectors as described in Degopt.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.get_degopt_crefs","page":"Built-in graphs","title":"GraphMatFun.get_degopt_crefs","text":"(x,z)=get_degopt_crefs(k)\n(x,z)=get_degopt_crefs(graph)\n\nReturns linear combination references (crefs) related to graph_degopt. Specifically x is a Vector{Tuple{Vector{Tuple{Symbol,Int}},Vector{Tuple{Symbol,Int}}}} such that x[2][1] corresponds to the coefficients of the left hand side of the multiplication\n\nB2=(α_2_1 *I + α_2_2 *A)(β_2_1 *I + β_2_2 *A)\n\ni.e., the crefs corresponding to [α_2_1, α_2_2]. See graph_degopt. Hence, get_coeffs(graph,x[2][1]) returns the corresponding numerical values of the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_sastre_yks_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_sastre_yks_degopt","text":"(graph,cref)=graph_sastre_yks_degopt(k,s,c)\n\nTransforms the polynomial evaluation format given by equations (62)-(65) in the reference to degop-format. The graph is a representation of y_{k,s}. Input c is a grouping of the coefficients as given by the representation (62)-(65). c is a Vector{Vector{Vector}} of length k+1, representing\n\n[\n[c_i^{(0,1)}, c_i^{(0,2)}]\n[c_i^{(1,1)}, c_i^{(1,2)}, c_i^{(1,3)}, c_i^{(1,4)}, c_i^{(1,5)}, c_i^{(1,6)}]\n...\n[c_i^{(k,1)}, c_i^{(k,2)}, c_i^{(k,3)}, c_i^{(k,4)}, c_i^{(k,5)}, c_i^{(k,6)}]\n]\n\nHence, c[1] contains two vectors, the first of length s-1 and the second of length s. (Note: In the first vector the constant for I is set to zero) and c[2] up to c[k+1] conatins six vectors: Even-numbered vectors have length s+1 Odd-numbered vectors have length j-1, where j is the intex in c, e.g., c[2][1] has one element and c[3][5] have two. For example, equations (57)-(59) are implemented as:\n\nc = [\n[[c15, c16], [0.0, 0, 0]], # (57)\n[[1.0], [0, c13, c14], [1.0], [c11, 0, c12], [c10], [0.0, 0, 0]], # (58)\n[[0.0, 1], [0, c8, c9], [c7, 1], [0, c6, 0], [c4, c5], [c1, c2, c3]], # (59)\n]\n\nReference\n\nJ. Sastre. \"Efficient evaluation of matrix polynomials\". Linear Algebra and its Applications, 539:229-250, 2018. DOI: 10.1016/j.laa.2017.11.010\n\n\n\n\n\n","category":"function"},{"location":"generators/#Rational-functions","page":"Built-in graphs","title":"Rational functions","text":"","category":"section"},{"location":"generators/","page":"Built-in graphs","title":"Built-in graphs","text":"graph_rational","category":"page"},{"location":"generators/#GraphMatFun.graph_rational","page":"Built-in graphs","title":"GraphMatFun.graph_rational","text":" (graph, cref) = graph_rational(den_coeffs, num_coeffs, poly_gen=graph_ps)\n (graph, cref) = graph_rational(\n    den_graph,\n    num_graph;\n    den_cref = Vector{Tuple{Symbol,Int}}(),\n    num_cref = Vector{Tuple{Symbol,Int}}(),\n)\n\nGenerates the graph for the rational approximation\n\nr(A)=q(A)^{-1}p(A)\n\nwhere p(A) and q(A) are polynomials defined by the coefficients den_coeffs and num_coeffs, and generated by the function poly_gen, which is called as (graph,cref)=poly_gen(coeffs), see, e.g., graph_monomial and graph_ps.\n\nThe alternative call-signature involves the graphs for p and q directly, as den_graph and num_graph. The corresponding den_cref and num_cref can also be passed to be modified accordingly, otherwise the return value cref is empty for this call.\n\n\n\n\n\n","category":"function"},{"location":"generators/#Matrix-exponential","page":"Built-in graphs","title":"Matrix exponential","text":"","category":"section"},{"location":"generators/","page":"Built-in graphs","title":"Built-in graphs","text":"One of the most important matrix functions is the matrix exponential. The package contains graph-representations for several of the state-of-the-art evaluation schemes.","category":"page"},{"location":"generators/","page":"Built-in graphs","title":"Built-in graphs","text":"graph_exp_native_jl\ngraph_exp_native_jl_degopt\ngraph_sastre_exp\ngraph_sid_exp\ngraph_bbc_exp\ngraph_bbcs_cheb_exp","category":"page"},{"location":"generators/#GraphMatFun.graph_exp_native_jl","page":"Built-in graphs","title":"GraphMatFun.graph_exp_native_jl","text":" (graph,crefs)=graph_exp_native_jl(A; input=:A)\n\nCreates a graph for the native scaling-and-squaring for the matrix exponential, as implemented in Julia. The matrix A is taken as input to determine the length of the Padé approximant and the number of squares applied, as well as determining the type of the coefficients. The kwarg input determines the name of the matrix, in the graph.\n\nReferences\n\nN. J. Higham. \"Functions of Matrices\". SIAM, Philadelphia, PA, 2008. DOI: 10.1137/1.9780898717778\nN. J. Higham. \"The Scaling and Squaring Method for the Matrix Exponential Revisited\". SIAM Journal on Matrix Analysis and Applications, 26(4):1179-1193, 2005. DOI: 10.1137/04061101X\n\"Julia's matrix exponential\", at the time of conversion.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_exp_native_jl_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_exp_native_jl_degopt","text":" (graph,crefs)=graph_exp_native_jl_degopt(A; input=:A)\n\nSame as graph_exp_native_jl but with calls to graph_degopt for contruction of numerator and denominator polynomials.\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_sastre_exp","page":"Built-in graphs","title":"GraphMatFun.graph_sastre_exp","text":"(graph,cref)=graph_sastre_exp(k,method=:auto)\n\nComputes a polynomial evaluation approximating the exponential using k matrix multiplications following a method given in the reference. The schemes are embedded into degop-format, see graph_degopt.\n\nThe methods are (from the paper referenced below):\n\n:ps_degopt, Paterson–Stockmeyer method embedded into degopt-format.\n:y1s, given by equations (34)-(35)\n:z1ps, given by equations (34)-(35) and (52)\n:h2m, given by equations (34)-(35) and (69)\n\nNot all combinations of k and method are implemented. Available ones are:\n\nk<3, method=:ps_degopt\nk=3, method=:y1s, as per Table 4 in the reference\nk=4, method=:y1s\nk=6, method=:h2m, as per Table 11 in the reference\nk=8, method=:z1ps, as per Table 7 in the reference\n\nThe default option method=:auto will choose method according to the value of k, as prescribed above.\n\nReference\n\nJ. Sastre. \"Efficient evaluation of matrix polynomials\". Linear Algebra and its Applications, 539:229-250, 2018. DOI: 10.1016/j.laa.2017.11.010\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_sid_exp","page":"Built-in graphs","title":"GraphMatFun.graph_sid_exp","text":"(graph,cref)=graph_sid_exp(k;T=Float64)\n\nComputes a polynomial evaluation approximating the exponential using k matrix multiplications following the procedure in the reference. The coefficients are directly copied from the paper.\n\nThe evaluation is embedded in the degopt-format, see graph_degopt, using the function graph_sastre_yks_degopt. Moreover, for k<=3 it uses the Paterson–Stockmeyer method.\n\nReference\n\nJ. Sastre, J. Ibáñez, E. Defez. \"Boosting the computation of the matrix exponential\". Applied Mathematics of Computation, 340:206-220, 2019. DOI: 10.1016/j.amc.2018.08.017\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_bbc_exp","page":"Built-in graphs","title":"GraphMatFun.graph_bbc_exp","text":"(graph,cref)=graph_bbc_exp(k;T=Float64)\n\nComputes a polynomial evaluation approximating the exponential using k matrix multiplications following the procedure in the reference. The coefficients are directly copied from the paper.\n\nThe evaluation is embedded in the degopt-format, see graph_degopt, and for k< 3, the evaluation is using the Paterson–Stockmeyer method.\n\nReference\n\nP. Bader, S. Blanes, and F. Casas. \"Computing the matrix exponential with an optimized Taylor polynomial approximation\". Mathematics, 7(12), 2019. DOI: 10.3390/math7121174\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_bbcs_cheb_exp","page":"Built-in graphs","title":"GraphMatFun.graph_bbcs_cheb_exp","text":"(graph,cref)=graph_bbcs_cheb_exp(k;T=Complex{BigFloat})\n\nComputes a polynomial evaluation approximating the exponential for skew-Hermitian matrices using k matrix multiplications following the procedure in the reference.\n\nFor k > 5 it resorts to scaling-and-squaring of the k = 5 graph. The graph is in the degopt format, see graph_degopt.\n\nReference\n\nP. Bader, S. Blanes, F. Casas, M. Seydaoglu. \"An efficient algorithm to compute the exponential of skew-Hermitian matrices for the time integration of the Schrödinger equation\". arXiv:2103.10132 [math.NA], 2021.\n\n\n\n\n\n","category":"function"},{"location":"generators/#Other-matrix-functions-and-iterations","page":"Built-in graphs","title":"Other matrix functions and iterations","text":"","category":"section"},{"location":"generators/","page":"Built-in graphs","title":"Built-in graphs","text":"graph_denman_beavers\ngraph_newton_schulz\ngraph_newton_schulz_degopt","category":"page"},{"location":"generators/#GraphMatFun.graph_denman_beavers","page":"Built-in graphs","title":"GraphMatFun.graph_denman_beavers","text":"    (graph,cref)=graph_denman_beavers(k;T=ComplexF64,cref_mode=0)\n\nCreates the graph corresponding to the Denman–Beavers iteration for the matrix square root, using k iterations. The kwarg cref_mode specifies if references to all X and Y (cref_mode=0) should be stored or just Y (cref_mode=-1) or just X (cref_mode=1).\n\nReference\n\nE. Denman and A. Beavers. \"The matrix sign function and computations in systems\". Applied Mathematics and Computation, 2(1), 1976. DOI: 10.1016/0096-3003(76)90020-5\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_newton_schulz","page":"Built-in graphs","title":"GraphMatFun.graph_newton_schulz","text":" (graph,crefs)=graph_newton_schulz(\n    k,\n    T = ComplexF64;\n    input = :A,\n    Z = :Z,\n    Q = :Q,\n    V = :V,\n)\n\nDoes k iterations of the Newton–Schulz iteration for approximating the inverse of a matrix A (name given by input), i.e., the recursion\n\nV_k+1 = V_k*(2*I - A*V_k),\n\nwith V_0=A. The recursion is implemented using the graph operations\n\nZ_i=A*V_i\nQ_i=2*I-Z_i\nV_{i+1}=V_i*Q_i,\n\nand the kwargs Z, Q, and V determines the naming of the corresponding intermediate steps.\n\nReferences\n\nG. Schulz. \"Iterative Berechnung der reziproken Matrix\". Zeitschrift für Angewandte Mathematik und Mechanik, 13:57–59, 1933. DOI: 10.1002/zamm.19330130111\nN. J. Higham. \"Functions of Matrices\". SIAM, Philadelphia, PA, 2008. DOI: 10.1137/1.9780898717778\n\n\n\n\n\n","category":"function"},{"location":"generators/#GraphMatFun.graph_newton_schulz_degopt","page":"Built-in graphs","title":"GraphMatFun.graph_newton_schulz_degopt","text":" (graph,crefs)=graph_newton_schulz_degopt(k, T=ComplexF64; input=:A)\n\nDoes k iterations of the Newton–Schulz iteration for approximating the inverse, using the recursion\n\nZ_i=A*V_i\nV_{i+1}=V_i*(2*I-Z_i).\n\nThe function makes a call to graph_degopt, resulting in more degrees of freedom in crefs. See also graph_newton_schulz.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphMatFun","category":"page"},{"location":"#GraphMatFun.jl","page":"Home","title":"GraphMatFun.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphMatFun.jl is a Julia package for working with computational graphs representing functions of matrices.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is registered with the Julia central registry and can be installed with the command","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\n(v1.7) pkg> add GraphMatFun","category":"page"},{"location":"","page":"Home","title":"Home","text":"When installed, the package can be loaded into the current session by writing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using GraphMatFun","category":"page"},{"location":"#Building-a-first-graph","page":"Home","title":"Building a first graph","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider the following polynomial,","category":"page"},{"location":"","page":"Home","title":"Home","text":"p(x) = (1+2x+x^2)^2","category":"page"},{"location":"","page":"Home","title":"Home","text":"A graph representing p(x) can be manually constructed by defining the operations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> graph = Compgraph(Float64);\njulia> add_mult!(graph,:A2,:A,:A);\njulia> add_lincomb!(graph,:P1,1.0,:I,2.0,:A);\njulia> add_lincomb!(graph,:P2,1.0,:A2,1.0,:P1);\njulia> add_mult!(graph,:P,:P2,:P2);\njulia> add_output!(graph,:P);","category":"page"},{"location":"","page":"Home","title":"Home","text":"The graph can be evaluated in both scalars, vectors, and matrices. For vectors the evaluation is elementwise.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> x = [1, 2, 3.5];\njulia> eval_graph(graph, x)\n3-element Vector{Float64}:\n  16.0\n  81.0\n 410.0625\njulia> (1 .+ 2*x + x.^2).^2\n3-element Vector{Float64}:\n  16.0\n  81.0\n 410.0625\njulia> A = [1 3; 7 2.0];\njulia> eval_graph(graph, A)\n2×2 Matrix{Float64}:\n 1150.0   825.0\n 1925.0  1425.0\njulia> (I + 2*A + A^2)^2\n2×2 Matrix{Float64}:\n 1150.0   825.0\n 1925.0  1425.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since the graph is a polynomial the coefficients can be directly extracted.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> get_polynomial_coefficients(graph)\n5-element Vector{Float64}:\n 1.0\n 4.0\n 6.0\n 4.0\n 1.0","category":"page"},{"location":"#How-do-I-cite-it?","page":"Home","title":"How do I cite it?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find this software useful, please cite the open access article:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@Article{jfr22,\n  author = \"Jarlebring, Elias and Fasi, Massimiliano and Ringh, Emil\",\n  title = \"Computational Graphs for Matrix Functions\",\n  journal = \"ACM Trans. Math. Software\",\n  year = 2023,\n  volume = 48,\n  number = 4,\n  pages = \"1-35\",\n  month = mar,\n  doi = \"10.1145/3568991\"\n  }","category":"page"},{"location":"","page":"Home","title":"Home","text":"Previous versions of the manuscript are available as arXiv:2107.12198 [math.NA] and MIMS Eprint 2021.12.","category":"page"},{"location":"optim/#Graph-optimization","page":"Graph optimization","title":"Graph optimization","text":"","category":"section"},{"location":"optim/","page":"Graph optimization","title":"Graph optimization","text":"For a fixed topology of the graph, the coefficients can be optimized. The package provides some routines for doing the optimization. However, by using the functions eval_graph and eval_jac, external routines based on function values and first derivatives can in principle be used.","category":"page"},{"location":"optim/","page":"Graph optimization","title":"Graph optimization","text":"opt_gauss_newton!\neval_jac\nopt_linear_fit!\nsolve_linlsqr!\nadjust_for_errtype!","category":"page"},{"location":"optim/#GraphMatFun.opt_gauss_newton!","page":"Graph optimization","title":"GraphMatFun.opt_gauss_newton!","text":"(iter,resnorm)=opt_gauss_newton!(\n    graph,\n    objfun,\n    discr;\n    maxit = 100,\n    logger = 0,\n    errtype = :abserr,\n    stoptol = 1e-6,\n    cref = get_all_cref(graph),\n    input = :A,\n    γ0 = 1.0,\n    linlsqr = :backslash,\n    droptol = 0,\n)\n\nApplies the Gauss–Newton algorithm to solve the nonlinear least squares problem: Fit the output of the graph to the values of objfun, in the points discr.\n\nThe variable graph is modified during the iterations. The function returns the iteration iter where it terminated, and the corresponding residual norm resnorm.\n\nThe kwargs are as follows:\n\nmaxit determines the maximum number of iterations. If logger has a value >0, then the intermediate results are printed.\nerrtype determines the error type measured, see adjust_for_errtype!.\nstoptol is the corresponding stopping tolerance.\ncref is a Vector{Tuple{Symbol,Int}} that determines which coefficients of graph that are considered free variables and optimized.\ninput is the label corresponding to the input node of the graph.\nThe stepsize can be scaled with γ0.\nlinlsqr and droptol determines how the inner linear least squares problem is solved; see solve_linlsqr!.\n\n\n\n\n\n","category":"function"},{"location":"optim/#GraphMatFun.eval_jac","page":"Graph optimization","title":"GraphMatFun.eval_jac","text":"J=eval_jac(\n    graph,\n    x,\n    cref;\n    vals = nothing,\n    input = :A,\n    output = size(graph.outputs, 1),\n)\n\nComputes Jacobian J = dZ(x_i)/dc, with respect to the coefficients given in the vector cref, and points in x. See eval_graph for description of vals and output.\n\n\n\n\n\n","category":"function"},{"location":"optim/#GraphMatFun.opt_linear_fit!","page":"Graph optimization","title":"GraphMatFun.opt_linear_fit!","text":"opt_linear_fit!(\n    graph,\n    objfun,\n    discr,\n    linear_cref;\n    input = :A,\n    errtype = :abserr,\n    linlsqr = :backslash,\n    droptol = 0,\n)\n\nLinear fitting of a graph of the form\n\nc_1 g_1(x) + c_2 g_2(x) + … + c_n g_n(x)\n\nto the values of objfun, in the points discr. Reference to the coefficients c_1,…,c_n should be given linear_cref.\n\nThe variable graph is modified during the iterations and the function has no return value.\n\nSee opt_gauss_newton! for a description the kwarg errtype and input, and solve_linlsqr! for the kwargs linlsqr anddroptol`.\n\n\n\n\n\n","category":"function"},{"location":"optim/#GraphMatFun.solve_linlsqr!","page":"Graph optimization","title":"GraphMatFun.solve_linlsqr!","text":"d = solve_linlsqr!(A, b, linlsqr, droptol)\n\nSolves the linear least squares problem\n\nAd=b.\n\nThe argument linlsqr determines how the linear least squares problem is solved. It can be :backslash, :real_backslash, :nrmeq, :real_nrmeq, :svd, or :real_svd. For the latter two options singular values below droptol are disregarded. The :real_X options optimizes d in the space of real vectors. The input matrix A is sometimes overwritten.\n\n\n\n\n\n","category":"function"},{"location":"optim/#GraphMatFun.adjust_for_errtype!","page":"Graph optimization","title":"GraphMatFun.adjust_for_errtype!","text":"adjust_for_errtype!(A, b, objfun_vals, errtype)\n\nAdjusts the matrix A and vector b to errtype. A is a matrix, e.g., the Jacobian or system matrix in a least squares problem. b is a vector, e.g., the residuals or the right-hand side in a lieast squares problem. objfun_vals is a vector of objective function values, and errtype can be :abserr or :relerr, i.e., absolute error or relative error.\n\n\n\n\n\n","category":"function"}]
}
