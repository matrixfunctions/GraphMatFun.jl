var documenterSearchIndex = {"docs":
[{"location":"graph/#Graphs-and-their-manipulation","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"","category":"section"},{"location":"graph/#Manipulating-graph-topology","page":"Graphs and their manipulation","title":"Manipulating graph topology","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"Compgraph\nadd_mult!\nadd_lincomb!\nadd_ldiv!\nadd_sum!\nadd_output!\ndel_output!\nclear_outputs!\nrename_node!\ndel_node!","category":"page"},{"location":"graph/#GraphMatFun.Compgraph","page":"Graphs and their manipulation","title":"GraphMatFun.Compgraph","text":"graph=Compgraph(T::Type=ComplexF64)\n\nCreates an empty computation graph of with coefficients of type T.\n\n\n\n\n\n\n\ngraph=Compgraph(T,orggraph::Compgraph)\n\nConverts a graph such that the coefficients become type T. Note that T can be a Number but can be other objects with defined operations, or just Any.\n\n\n\n\n\n\n\n","category":"type"},{"location":"graph/#GraphMatFun.add_mult!","page":"Graphs and their manipulation","title":"GraphMatFun.add_mult!","text":"add_mult!(graph,node,p1,p2)\n\nAdds a multiplication of node p1 and p2 to the graph. The result is stored in node node.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.add_lincomb!","page":"Graphs and their manipulation","title":"GraphMatFun.add_lincomb!","text":"add_lincomb!(graph,node,α1,p1,α2,p2)\n\nThe operation α1*p1+α2*p2 is added to the graph. The result is stored in node node.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.add_ldiv!","page":"Graphs and their manipulation","title":"GraphMatFun.add_ldiv!","text":"add_ldiv!(graph,node,p1,p2)\n\nThe operation inv(p1)*p2 is added to the graph. The result is stored in node node.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.add_sum!","page":"Graphs and their manipulation","title":"GraphMatFun.add_sum!","text":"cref=add_sum!(graph,node,c,nodelist,base_name=node)\n\nAdds a linear combination of more than two nodes, given in nodelist::Vector, with coefficients given in c. The base_name is temporary variables for the summing. The sum is stored in node.\n\nReturns cref list with references.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.add_output!","page":"Graphs and their manipulation","title":"GraphMatFun.add_output!","text":"add_output!(graph,node)\n\nAdds an output node to the graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.del_output!","page":"Graphs and their manipulation","title":"GraphMatFun.del_output!","text":"del_output!(graph,node)\n\nRemoves the output node from the list of output nodes of the graph. This function does not remove the node from the graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.clear_outputs!","page":"Graphs and their manipulation","title":"GraphMatFun.clear_outputs!","text":"clear_outputs!(graph)\n\nClears the list of output nodes of the graph. This function does not remove the node nodes from the graph.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.rename_node!","page":"Graphs and their manipulation","title":"GraphMatFun.rename_node!","text":"rename_node!(graph,src,dest,cref=Vector())\n\nThis changes the name of the node src to dest and updating all references to the node including coefficient references in cref.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.del_node!","page":"Graphs and their manipulation","title":"GraphMatFun.del_node!","text":"del_node!(graph,node)\n\nDeletes a node from the graph, and all data associated with it, except for graph.outputs.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Evaluating-of-graph","page":"Graphs and their manipulation","title":"Evaluating of graph","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"eval_graph\nget_topo_order","category":"page"},{"location":"graph/#GraphMatFun.eval_graph","page":"Graphs and their manipulation","title":"GraphMatFun.eval_graph","text":"result=eval_graph(graph, x; vals=nothing,\n                  input=:A, output=size(graph.outputs,1),\n                  comporder=nothing)\n\nEvaluates a graph in the value x which is typically a scalar value or a matrix. If x is a Vector, the values will be evaluated  elementwise.\n\nThe comporder is a Vector of nodes specifying in which order the graph should be computed. By default get_topo_order is used.\n\nThe output is an Int specifying which node should be considered as output. The output node is graph.outputs[output].\n\nThe vals is used to inspect contents other than the output inside the graph. Typically vals is a Dict. It will be modified to contain the computed nodes of the graph. If we wish to inspect node X3, we can initiate an empty dict as input:\n\njulia> vals=Dict{Symbol,Any}();\njulia> eval_graph(graph,A,vals=vals);\njulia> vals[:X3]\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.get_topo_order","page":"Graphs and their manipulation","title":"GraphMatFun.get_topo_order","text":"(order,can_be_deallocated,max_nodes)=get_topo_order(graph; priohelp=Dict{Symbol,Float64}(),free_mem_bonus=1000,will_not_deallocate=[:I],input=:A)\n\nComputes a topological sort of graph, that is, an ordering of the nodes following which the function the graph represents can be evaluated. The priohelp kwarg can be used to obtain a different topological ordering by changing the node priority. The code assumes that the nodes :I and input do not need to be computed.\n\nThe code uses a heuristic to minimize pathwidth. It is based on a point system. You can influence the computation order by providing a priohelp. If you want node :B4 to be computed earlier,  you can set priohelp[:B4]=-5000.0.  The free_mem_bonus is used in the heuristic to prioritize the computation of nodes which release other nodes. The vector will_not_deallocate influences the order specifying nodes that will not be deallocated and therefore gets no free_mem_bonus.\n\nThe return value order is a Vector of Symbols, and can_be_deallocated is a Vector{Vector{Symbol}} where the element i specifies the Symbols that are unused after step i in the ordering. The max_nodes is the pathwidth.\n\n\n\n\n\n\n\n","category":"function"},{"location":"graph/#Linear-combinations-and-coefficients","page":"Graphs and their manipulation","title":"Linear combinations and coefficients","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"get_all_cref\nget_coeffs\nset_coeffs!\nextract_sums\nget_sorted_keys","category":"page"},{"location":"graph/#GraphMatFun.get_all_cref","page":"Graphs and their manipulation","title":"GraphMatFun.get_all_cref","text":"v=get_all_cref(graph)\n\nReturns a list with references to all coefficients in the graph. The list is sorted.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.get_coeffs","page":"Graphs and their manipulation","title":"GraphMatFun.get_coeffs","text":"x=get_coeffs(graph, cref=get_all_cref(graph))\n\nGets the coefficient values for the coefficients specified in cref::Vector.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.set_coeffs!","page":"Graphs and their manipulation","title":"GraphMatFun.set_coeffs!","text":"set_coeffs!(graph, x, cref=get_all_cref(graph))\n\nSets the coefficient values in the coefficients specified in cref::Vector to the values in the vector in x::Vector.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.extract_sums","page":"Graphs and their manipulation","title":"GraphMatFun.extract_sums","text":"v=extract_sums(graph)\n\n::Vector{Tuple{Vector{Float64},Vector{Symbol},Vector{Symbol}}}`\n\nReturns a representation of sums in graph which may potentially be merged. The vector sums contains a tuple for each of these sums. The three entries of the tuple are:\n\na vector of Float64 values that represent the coefficients of the summands;\na vector of Symbols that correspond to the summands; and\na vector of intermediate Symbols (i.e, nodes) that can be merged.\n\nThe first two vectors have the same number of entries, one for each element that can be merged in the sum.\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.get_sorted_keys","page":"Graphs and their manipulation","title":"GraphMatFun.get_sorted_keys","text":"v=get_sorted_keys(graph)\n\nReturns a list of all nodes, sorted.\n\n\n\n\n\n","category":"function"},{"location":"graph/#Reading-and-writing-to-file","page":"Graphs and their manipulation","title":"Reading and writing to file","text":"","category":"section"},{"location":"graph/","page":"Graphs and their manipulation","title":"Graphs and their manipulation","text":"export_compgraph\nimport_compgraph","category":"page"},{"location":"graph/#GraphMatFun.export_compgraph","page":"Graphs and their manipulation","title":"GraphMatFun.export_compgraph","text":"export_compgraph(graph, fname; main_output=nothing,\n                 order=get_topo_order(graph)[1],\n                 fun=\"\", dom=\"\", err=\"\", genby=\"\",\n                 descr=\"\",\n                 user=current user)\n\nExports the graph to the file fname using the computation graph format (cgr). These kwargs are strings or values that are stored as comments in the file\n\ndescr of the graph\nfun function it approximates\ndom domain it approximates\nerr error in this domain\ngenby script that generated this file\nuser a username that created the file\n\nThese kwarg influence how the graph is stored:\n\norder specifies an order the graph nodes are stored\nmain_output is a Symbol specifying what is the output.\n\nCGR format:\n\nEvery line corresponds to a node / operation. The syntax is matlab compatible, although gen_code produces faster matlab code.\n\nSee also export_compgraph.\n\n\n\n\n\n\n\n","category":"function"},{"location":"graph/#GraphMatFun.import_compgraph","page":"Graphs and their manipulation","title":"GraphMatFun.import_compgraph","text":"graph=import_compgraph(fname)\n\nReads a graph stored in the computation graph format (cgr) in the file fname.\n\nSee also import_compgraph.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#Code-generation","page":"Code generation","title":"Code generation","text":"","category":"section"},{"location":"code_gen/","page":"Code generation","title":"Code generation","text":"gen_code\nLangJulia\nLangMatlab\nLangC_MKL\nLangC_OpenBLAS","category":"page"},{"location":"code_gen/#GraphMatFun.gen_code","page":"Code generation","title":"GraphMatFun.gen_code","text":"gen_code(fname,graph; priohelp=Dict{Symbol,Float64}(),\n         lang=LangJulia(),funname=\"dummy\",precomputed_nodes=[:A])\n\nGenerates the code for the graph in the language  specified in lang and writes it into the file fname. The string funname is the function name. Topological order of the nodes is comptued using get_topo_order and priohelp can be used to influence the order. The nodes listed in precomputed_nodes are viewed as inputs, and code to compute these nodes are not computed.\n\nCurrently supported languages: LangC_MKL, LangC_OpenBLAS,  LangJulia, LangMatlab.\n\n\n\n\n\n","category":"function"},{"location":"code_gen/#GraphMatFun.LangJulia","page":"Code generation","title":"GraphMatFun.LangJulia","text":"LangJulia(overwrite_input=true,inline=true,dot_fusing=true)\n\nCode generation in julia language, with optional overwriting of input, inlining the function and optional usage of dot fusion.\n\n\n\n\n\n","category":"type"},{"location":"code_gen/#GraphMatFun.LangMatlab","page":"Code generation","title":"GraphMatFun.LangMatlab","text":"LangMatlab()\n\nCode generation for the Matlab language.\n\n\n\n\n\n","category":"type"},{"location":"code_gen/#GraphMatFun.LangC_MKL","page":"Code generation","title":"GraphMatFun.LangC_MKL","text":" LangC_MKL(gen_main::Bool)\n\nCode generation in C using MKL implementation of BLAS.\n\n\n\n\n\n","category":"type"},{"location":"code_gen/#GraphMatFun.LangC_OpenBLAS","page":"Code generation","title":"GraphMatFun.LangC_OpenBLAS","text":" LangC_OpenBLAS(gen_main::Bool)\n\nCode generation in C using OpenBLAS implementation of BLAS.\n\n\n\n\n\n","category":"type"},{"location":"generators/#Built-in-graphs","page":"Built-in graphs","title":"Built-in graphs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphMatFun","category":"page"},{"location":"#GraphMatFun.jl","page":"Home","title":"GraphMatFun.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphMatFun.jl is a Julia package for working with computational graphs representing functions of matrices.","category":"page"},{"location":"#Installing","page":"Home","title":"Installing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The latest release of the package can be installed as ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\n(v1.6) pkg> add GraphMatFun","category":"page"},{"location":"","page":"Home","title":"Home","text":"When installed, the package can be loaded into the current session by writing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using GraphMatFun","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"optim/#Graph-optimization","page":"Graph optimization","title":"Graph optimization","text":"","category":"section"},{"location":"optim/","page":"Graph optimization","title":"Graph optimization","text":"opt_gauss_newton!\neval_jac\nopt_linear_fit!\nsolve_linlsqr!\nadjust_for_errtype!","category":"page"},{"location":"optim/#GraphMatFun.opt_gauss_newton!","page":"Graph optimization","title":"GraphMatFun.opt_gauss_newton!","text":"(iter,resnorm)=opt_gauss_newton!(graph, objfun, discr; maxit = 100, logger = 0,\n                                 errtype = :abserr, stoptol = 1e-6,\n                                 input=:A, cref = get_all_cref(graph),\n                                 γ0 = 1.0, linlsqr = :backslash, droptol = 0)\n\nApplies the Gauss–Newton algorithm to solve the nonlinear least squares problem: Fit the output of the graph to the values of objfun, in the points discr.\n\nThe variable graph is modified during the iterations. The function returns the iteration iter where it terminated, and the corresponding residual norm resnorm.\n\nThe kwargs are as follows: maxit determines the maximum number of iterations. If logger has a value >0, then the intermediate results are printed. errtype determines the error type measured, see adjust_for_errtype!. stoptol is the corresponding stopping tolerence. cref is a Vector{Tuple{Symbol,Int}} that determines which coefficients of graph that are considered free variables and optimized. input is the label corresponding to the input node of the graph. The stepsize can be scaled with γ0. linlsqr and droptol determines how the inner linear least squares problem is solved; see solve_linlsqr!.\n\n\n\n\n\n\n\n","category":"function"},{"location":"optim/#GraphMatFun.eval_jac","page":"Graph optimization","title":"GraphMatFun.eval_jac","text":"J=eval_jac(graph, x, cref; vals=nothing,\n           input=:A, output=size(graph.outputs,1))\n\nComputes Jacobian J = dZ(x_i)/dc, with respect to the coefficients given in the vector cref, and points in x. See eval_graph for  description of vals and output.\n\n\n\n\n\n","category":"function"},{"location":"optim/#GraphMatFun.opt_linear_fit!","page":"Graph optimization","title":"GraphMatFun.opt_linear_fit!","text":"opt_linear_fit!(graph, objfun, discr, linear_cref;\n                input = :A,\n                errtype = :abserr,\n                linlsqr = :backslash,\n                droptol = 0)\n\nLinear fitting of a graph of the form\n\nc_1 g_1(x) + c_2 g_2(x) + … + c_n g_n(x)\n\nto the values of objfun, in the points discr. Reference to the coefficients c_1,…,c_n should be given linear_cref.\n\nThe variable graph is modified during the iterations and the function has no return value.\n\nSee opt_gauss_newton! for a description the kwarg errtype and input, and solve_linlsqr! for the kwargs linlsqr anddroptol`.\n\n\n\n\n\n\n\n","category":"function"},{"location":"optim/#GraphMatFun.solve_linlsqr!","page":"Graph optimization","title":"GraphMatFun.solve_linlsqr!","text":"d = solve_linlsqr!(A, b, linlsqr, droptol)\n\nSolves the linear least squares problem\n\nAd=b.\n\nThe argument linlsqr determines how the linear least squares problem is solved. It can be :backslash, :real_backslash, :nrmeq, :real_nrmeq, :svd, or :real_svd. For the latter two options singular values below droptol are disregarded. The :real_X options optimizes d in the space of real vectors. The input matrix A is sometimes overwritten.\n\n\n\n\n\n","category":"function"},{"location":"optim/#GraphMatFun.adjust_for_errtype!","page":"Graph optimization","title":"GraphMatFun.adjust_for_errtype!","text":"adjust_for_errtype!(A, b, objfun_vals, errtype)\n\nAdjusts the matrix A and vector b to errtype. A is a matrix, e.g., the Jacobian or system matrix in a least squares problem. b is a vector, e.g., the residuals or the right-hand side in a lieast squares problem. objfun_vals is a vector of objective function values, and errtype can be :abserr or :relerr, i.e., absolute error or relative error.\n\n\n\n\n\n","category":"function"}]
}
